
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Auth
 * 
 */
export type Auth = $Result.DefaultSelection<Prisma.$AuthPayload>
/**
 * Model Rol
 * 
 */
export type Rol = $Result.DefaultSelection<Prisma.$RolPayload>
/**
 * Model Categoria
 * 
 */
export type Categoria = $Result.DefaultSelection<Prisma.$CategoriaPayload>
/**
 * Model Emprendimiento
 * 
 */
export type Emprendimiento = $Result.DefaultSelection<Prisma.$EmprendimientoPayload>
/**
 * Model Producto
 * 
 */
export type Producto = $Result.DefaultSelection<Prisma.$ProductoPayload>
/**
 * Model RedesSociales
 * 
 */
export type RedesSociales = $Result.DefaultSelection<Prisma.$RedesSocialesPayload>
/**
 * Model Mentoria
 * 
 */
export type Mentoria = $Result.DefaultSelection<Prisma.$MentoriaPayload>
/**
 * Model Resena
 * 
 */
export type Resena = $Result.DefaultSelection<Prisma.$ResenaPayload>
/**
 * Model Promocion
 * 
 */
export type Promocion = $Result.DefaultSelection<Prisma.$PromocionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const EstadoEmprendimiento: {
  ACTIVO: 'ACTIVO',
  INACTIVO: 'INACTIVO',
  EN_REVISION: 'EN_REVISION',
  EN_INCUBACION: 'EN_INCUBACION'
};

export type EstadoEmprendimiento = (typeof EstadoEmprendimiento)[keyof typeof EstadoEmprendimiento]


export const EstadoMentoria: {
  PROGRAMADA: 'PROGRAMADA',
  COMPLETADA: 'COMPLETADA',
  CANCELADA: 'CANCELADA'
};

export type EstadoMentoria = (typeof EstadoMentoria)[keyof typeof EstadoMentoria]

}

export type EstadoEmprendimiento = $Enums.EstadoEmprendimiento

export const EstadoEmprendimiento: typeof $Enums.EstadoEmprendimiento

export type EstadoMentoria = $Enums.EstadoMentoria

export const EstadoMentoria: typeof $Enums.EstadoMentoria

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.auth`: Exposes CRUD operations for the **Auth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auths
    * const auths = await prisma.auth.findMany()
    * ```
    */
  get auth(): Prisma.AuthDelegate<ExtArgs>;

  /**
   * `prisma.rol`: Exposes CRUD operations for the **Rol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rols
    * const rols = await prisma.rol.findMany()
    * ```
    */
  get rol(): Prisma.RolDelegate<ExtArgs>;

  /**
   * `prisma.categoria`: Exposes CRUD operations for the **Categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.CategoriaDelegate<ExtArgs>;

  /**
   * `prisma.emprendimiento`: Exposes CRUD operations for the **Emprendimiento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emprendimientos
    * const emprendimientos = await prisma.emprendimiento.findMany()
    * ```
    */
  get emprendimiento(): Prisma.EmprendimientoDelegate<ExtArgs>;

  /**
   * `prisma.producto`: Exposes CRUD operations for the **Producto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Productos
    * const productos = await prisma.producto.findMany()
    * ```
    */
  get producto(): Prisma.ProductoDelegate<ExtArgs>;

  /**
   * `prisma.redesSociales`: Exposes CRUD operations for the **RedesSociales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RedesSociales
    * const redesSociales = await prisma.redesSociales.findMany()
    * ```
    */
  get redesSociales(): Prisma.RedesSocialesDelegate<ExtArgs>;

  /**
   * `prisma.mentoria`: Exposes CRUD operations for the **Mentoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentorias
    * const mentorias = await prisma.mentoria.findMany()
    * ```
    */
  get mentoria(): Prisma.MentoriaDelegate<ExtArgs>;

  /**
   * `prisma.resena`: Exposes CRUD operations for the **Resena** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resenas
    * const resenas = await prisma.resena.findMany()
    * ```
    */
  get resena(): Prisma.ResenaDelegate<ExtArgs>;

  /**
   * `prisma.promocion`: Exposes CRUD operations for the **Promocion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promocions
    * const promocions = await prisma.promocion.findMany()
    * ```
    */
  get promocion(): Prisma.PromocionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Auth: 'Auth',
    Rol: 'Rol',
    Categoria: 'Categoria',
    Emprendimiento: 'Emprendimiento',
    Producto: 'Producto',
    RedesSociales: 'RedesSociales',
    Mentoria: 'Mentoria',
    Resena: 'Resena',
    Promocion: 'Promocion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "auth" | "rol" | "categoria" | "emprendimiento" | "producto" | "redesSociales" | "mentoria" | "resena" | "promocion"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Auth: {
        payload: Prisma.$AuthPayload<ExtArgs>
        fields: Prisma.AuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          findFirst: {
            args: Prisma.AuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          findMany: {
            args: Prisma.AuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>[]
          }
          create: {
            args: Prisma.AuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          createMany: {
            args: Prisma.AuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          update: {
            args: Prisma.AuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          deleteMany: {
            args: Prisma.AuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthPayload>
          }
          aggregate: {
            args: Prisma.AuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuth>
          }
          groupBy: {
            args: Prisma.AuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthCountArgs<ExtArgs>
            result: $Utils.Optional<AuthCountAggregateOutputType> | number
          }
        }
      }
      Rol: {
        payload: Prisma.$RolPayload<ExtArgs>
        fields: Prisma.RolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findFirst: {
            args: Prisma.RolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findMany: {
            args: Prisma.RolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          create: {
            args: Prisma.RolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          createMany: {
            args: Prisma.RolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          update: {
            args: Prisma.RolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          deleteMany: {
            args: Prisma.RolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          aggregate: {
            args: Prisma.RolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRol>
          }
          groupBy: {
            args: Prisma.RolGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolCountArgs<ExtArgs>
            result: $Utils.Optional<RolCountAggregateOutputType> | number
          }
        }
      }
      Categoria: {
        payload: Prisma.$CategoriaPayload<ExtArgs>
        fields: Prisma.CategoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findFirst: {
            args: Prisma.CategoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          findMany: {
            args: Prisma.CategoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>[]
          }
          create: {
            args: Prisma.CategoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          createMany: {
            args: Prisma.CategoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          update: {
            args: Prisma.CategoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          deleteMany: {
            args: Prisma.CategoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.CategoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoriaCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      Emprendimiento: {
        payload: Prisma.$EmprendimientoPayload<ExtArgs>
        fields: Prisma.EmprendimientoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmprendimientoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmprendimientoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          findFirst: {
            args: Prisma.EmprendimientoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmprendimientoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          findMany: {
            args: Prisma.EmprendimientoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>[]
          }
          create: {
            args: Prisma.EmprendimientoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          createMany: {
            args: Prisma.EmprendimientoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmprendimientoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          update: {
            args: Prisma.EmprendimientoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          deleteMany: {
            args: Prisma.EmprendimientoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmprendimientoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmprendimientoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmprendimientoPayload>
          }
          aggregate: {
            args: Prisma.EmprendimientoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmprendimiento>
          }
          groupBy: {
            args: Prisma.EmprendimientoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmprendimientoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmprendimientoCountArgs<ExtArgs>
            result: $Utils.Optional<EmprendimientoCountAggregateOutputType> | number
          }
        }
      }
      Producto: {
        payload: Prisma.$ProductoPayload<ExtArgs>
        fields: Prisma.ProductoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findFirst: {
            args: Prisma.ProductoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          findMany: {
            args: Prisma.ProductoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>[]
          }
          create: {
            args: Prisma.ProductoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          createMany: {
            args: Prisma.ProductoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          update: {
            args: Prisma.ProductoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          deleteMany: {
            args: Prisma.ProductoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductoPayload>
          }
          aggregate: {
            args: Prisma.ProductoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducto>
          }
          groupBy: {
            args: Prisma.ProductoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductoCountArgs<ExtArgs>
            result: $Utils.Optional<ProductoCountAggregateOutputType> | number
          }
        }
      }
      RedesSociales: {
        payload: Prisma.$RedesSocialesPayload<ExtArgs>
        fields: Prisma.RedesSocialesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedesSocialesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedesSocialesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedesSocialesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedesSocialesPayload>
          }
          findFirst: {
            args: Prisma.RedesSocialesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedesSocialesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedesSocialesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedesSocialesPayload>
          }
          findMany: {
            args: Prisma.RedesSocialesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedesSocialesPayload>[]
          }
          create: {
            args: Prisma.RedesSocialesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedesSocialesPayload>
          }
          createMany: {
            args: Prisma.RedesSocialesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RedesSocialesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedesSocialesPayload>
          }
          update: {
            args: Prisma.RedesSocialesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedesSocialesPayload>
          }
          deleteMany: {
            args: Prisma.RedesSocialesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedesSocialesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RedesSocialesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedesSocialesPayload>
          }
          aggregate: {
            args: Prisma.RedesSocialesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedesSociales>
          }
          groupBy: {
            args: Prisma.RedesSocialesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedesSocialesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedesSocialesCountArgs<ExtArgs>
            result: $Utils.Optional<RedesSocialesCountAggregateOutputType> | number
          }
        }
      }
      Mentoria: {
        payload: Prisma.$MentoriaPayload<ExtArgs>
        fields: Prisma.MentoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentoriaPayload>
          }
          findFirst: {
            args: Prisma.MentoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentoriaPayload>
          }
          findMany: {
            args: Prisma.MentoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentoriaPayload>[]
          }
          create: {
            args: Prisma.MentoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentoriaPayload>
          }
          createMany: {
            args: Prisma.MentoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MentoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentoriaPayload>
          }
          update: {
            args: Prisma.MentoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentoriaPayload>
          }
          deleteMany: {
            args: Prisma.MentoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MentoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentoriaPayload>
          }
          aggregate: {
            args: Prisma.MentoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentoria>
          }
          groupBy: {
            args: Prisma.MentoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentoriaCountArgs<ExtArgs>
            result: $Utils.Optional<MentoriaCountAggregateOutputType> | number
          }
        }
      }
      Resena: {
        payload: Prisma.$ResenaPayload<ExtArgs>
        fields: Prisma.ResenaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResenaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResenaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          findFirst: {
            args: Prisma.ResenaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResenaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          findMany: {
            args: Prisma.ResenaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>[]
          }
          create: {
            args: Prisma.ResenaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          createMany: {
            args: Prisma.ResenaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ResenaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          update: {
            args: Prisma.ResenaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          deleteMany: {
            args: Prisma.ResenaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResenaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResenaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResenaPayload>
          }
          aggregate: {
            args: Prisma.ResenaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResena>
          }
          groupBy: {
            args: Prisma.ResenaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResenaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResenaCountArgs<ExtArgs>
            result: $Utils.Optional<ResenaCountAggregateOutputType> | number
          }
        }
      }
      Promocion: {
        payload: Prisma.$PromocionPayload<ExtArgs>
        fields: Prisma.PromocionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromocionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromocionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          findFirst: {
            args: Prisma.PromocionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromocionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          findMany: {
            args: Prisma.PromocionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>[]
          }
          create: {
            args: Prisma.PromocionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          createMany: {
            args: Prisma.PromocionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PromocionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          update: {
            args: Prisma.PromocionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          deleteMany: {
            args: Prisma.PromocionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromocionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromocionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromocionPayload>
          }
          aggregate: {
            args: Prisma.PromocionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromocion>
          }
          groupBy: {
            args: Prisma.PromocionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromocionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromocionCountArgs<ExtArgs>
            result: $Utils.Optional<PromocionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    roles: number
    emprendimientos: number
    mentoriasComoTutor: number
    resenas: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | UsuarioCountOutputTypeCountRolesArgs
    emprendimientos?: boolean | UsuarioCountOutputTypeCountEmprendimientosArgs
    mentoriasComoTutor?: boolean | UsuarioCountOutputTypeCountMentoriasComoTutorArgs
    resenas?: boolean | UsuarioCountOutputTypeCountResenasArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEmprendimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprendimientoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountMentoriasComoTutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentoriaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountResenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResenaWhereInput
  }


  /**
   * Count Type RolCountOutputType
   */

  export type RolCountOutputType = {
    usuarios: number
  }

  export type RolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | RolCountOutputTypeCountUsuariosArgs
  }

  // Custom InputTypes
  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolCountOutputType
     */
    select?: RolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }


  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    emprendimientos: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimientos?: boolean | CategoriaCountOutputTypeCountEmprendimientosArgs
  }

  // Custom InputTypes
  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountEmprendimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprendimientoWhereInput
  }


  /**
   * Count Type EmprendimientoCountOutputType
   */

  export type EmprendimientoCountOutputType = {
    productos: number
    mentorias: number
    resenas: number
    promociones: number
  }

  export type EmprendimientoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productos?: boolean | EmprendimientoCountOutputTypeCountProductosArgs
    mentorias?: boolean | EmprendimientoCountOutputTypeCountMentoriasArgs
    resenas?: boolean | EmprendimientoCountOutputTypeCountResenasArgs
    promociones?: boolean | EmprendimientoCountOutputTypeCountPromocionesArgs
  }

  // Custom InputTypes
  /**
   * EmprendimientoCountOutputType without action
   */
  export type EmprendimientoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmprendimientoCountOutputType
     */
    select?: EmprendimientoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmprendimientoCountOutputType without action
   */
  export type EmprendimientoCountOutputTypeCountProductosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
  }

  /**
   * EmprendimientoCountOutputType without action
   */
  export type EmprendimientoCountOutputTypeCountMentoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentoriaWhereInput
  }

  /**
   * EmprendimientoCountOutputType without action
   */
  export type EmprendimientoCountOutputTypeCountResenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResenaWhereInput
  }

  /**
   * EmprendimientoCountOutputType without action
   */
  export type EmprendimientoCountOutputTypeCountPromocionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromocionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    email: string | null
    telefono: string | null
    fechaRegistro: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    email: string | null
    telefono: string | null
    fechaRegistro: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    email: number
    telefono: number
    fechaRegistro: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    telefono?: true
    fechaRegistro?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    telefono?: true
    fechaRegistro?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    telefono?: true
    fechaRegistro?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nombre: string
    apellido: string
    email: string
    telefono: string | null
    fechaRegistro: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    telefono?: boolean
    fechaRegistro?: boolean
    auth?: boolean | Usuario$authArgs<ExtArgs>
    roles?: boolean | Usuario$rolesArgs<ExtArgs>
    emprendimientos?: boolean | Usuario$emprendimientosArgs<ExtArgs>
    mentoriasComoTutor?: boolean | Usuario$mentoriasComoTutorArgs<ExtArgs>
    resenas?: boolean | Usuario$resenasArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type UsuarioSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    telefono?: boolean
    fechaRegistro?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auth?: boolean | Usuario$authArgs<ExtArgs>
    roles?: boolean | Usuario$rolesArgs<ExtArgs>
    emprendimientos?: boolean | Usuario$emprendimientosArgs<ExtArgs>
    mentoriasComoTutor?: boolean | Usuario$mentoriasComoTutorArgs<ExtArgs>
    resenas?: boolean | Usuario$resenasArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      auth: Prisma.$AuthPayload<ExtArgs> | null
      roles: Prisma.$RolPayload<ExtArgs>[]
      emprendimientos: Prisma.$EmprendimientoPayload<ExtArgs>[]
      mentoriasComoTutor: Prisma.$MentoriaPayload<ExtArgs>[]
      resenas: Prisma.$ResenaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellido: string
      email: string
      telefono: string | null
      fechaRegistro: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auth<T extends Usuario$authArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$authArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    roles<T extends Usuario$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findMany"> | Null>
    emprendimientos<T extends Usuario$emprendimientosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$emprendimientosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findMany"> | Null>
    mentoriasComoTutor<T extends Usuario$mentoriasComoTutorArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$mentoriasComoTutorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "findMany"> | Null>
    resenas<T extends Usuario$resenasArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$resenasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellido: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly telefono: FieldRef<"Usuario", 'String'>
    readonly fechaRegistro: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.auth
   */
  export type Usuario$authArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    where?: AuthWhereInput
  }

  /**
   * Usuario.roles
   */
  export type Usuario$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    where?: RolWhereInput
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    cursor?: RolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Usuario.emprendimientos
   */
  export type Usuario$emprendimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    where?: EmprendimientoWhereInput
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    cursor?: EmprendimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Usuario.mentoriasComoTutor
   */
  export type Usuario$mentoriasComoTutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    where?: MentoriaWhereInput
    orderBy?: MentoriaOrderByWithRelationInput | MentoriaOrderByWithRelationInput[]
    cursor?: MentoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentoriaScalarFieldEnum | MentoriaScalarFieldEnum[]
  }

  /**
   * Usuario.resenas
   */
  export type Usuario$resenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    where?: ResenaWhereInput
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    cursor?: ResenaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Auth
   */

  export type AggregateAuth = {
    _count: AuthCountAggregateOutputType | null
    _avg: AuthAvgAggregateOutputType | null
    _sum: AuthSumAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  export type AuthAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type AuthSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type AuthMinAggregateOutputType = {
    id: number | null
    password: string | null
    usuarioId: number | null
  }

  export type AuthMaxAggregateOutputType = {
    id: number | null
    password: string | null
    usuarioId: number | null
  }

  export type AuthCountAggregateOutputType = {
    id: number
    password: number
    usuarioId: number
    _all: number
  }


  export type AuthAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AuthSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AuthMinAggregateInputType = {
    id?: true
    password?: true
    usuarioId?: true
  }

  export type AuthMaxAggregateInputType = {
    id?: true
    password?: true
    usuarioId?: true
  }

  export type AuthCountAggregateInputType = {
    id?: true
    password?: true
    usuarioId?: true
    _all?: true
  }

  export type AuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auth to aggregate.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auths
    **/
    _count?: true | AuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthMaxAggregateInputType
  }

  export type GetAuthAggregateType<T extends AuthAggregateArgs> = {
        [P in keyof T & keyof AggregateAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuth[P]>
      : GetScalarType<T[P], AggregateAuth[P]>
  }




  export type AuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthWhereInput
    orderBy?: AuthOrderByWithAggregationInput | AuthOrderByWithAggregationInput[]
    by: AuthScalarFieldEnum[] | AuthScalarFieldEnum
    having?: AuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthCountAggregateInputType | true
    _avg?: AuthAvgAggregateInputType
    _sum?: AuthSumAggregateInputType
    _min?: AuthMinAggregateInputType
    _max?: AuthMaxAggregateInputType
  }

  export type AuthGroupByOutputType = {
    id: number
    password: string
    usuarioId: number
    _count: AuthCountAggregateOutputType | null
    _avg: AuthAvgAggregateOutputType | null
    _sum: AuthSumAggregateOutputType | null
    _min: AuthMinAggregateOutputType | null
    _max: AuthMaxAggregateOutputType | null
  }

  type GetAuthGroupByPayload<T extends AuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthGroupByOutputType[P]>
            : GetScalarType<T[P], AuthGroupByOutputType[P]>
        }
      >
    >


  export type AuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    password?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auth"]>


  export type AuthSelectScalar = {
    id?: boolean
    password?: boolean
    usuarioId?: boolean
  }

  export type AuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $AuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auth"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      password: string
      usuarioId: number
    }, ExtArgs["result"]["auth"]>
    composites: {}
  }

  type AuthGetPayload<S extends boolean | null | undefined | AuthDefaultArgs> = $Result.GetResult<Prisma.$AuthPayload, S>

  type AuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuthFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthCountAggregateInputType | true
    }

  export interface AuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auth'], meta: { name: 'Auth' } }
    /**
     * Find zero or one Auth that matches the filter.
     * @param {AuthFindUniqueArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthFindUniqueArgs>(args: SelectSubset<T, AuthFindUniqueArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Auth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuthFindUniqueOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Auth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindFirstArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthFindFirstArgs>(args?: SelectSubset<T, AuthFindFirstArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Auth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindFirstOrThrowArgs} args - Arguments to find a Auth
     * @example
     * // Get one Auth
     * const auth = await prisma.auth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Auths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auths
     * const auths = await prisma.auth.findMany()
     * 
     * // Get first 10 Auths
     * const auths = await prisma.auth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authWithIdOnly = await prisma.auth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthFindManyArgs>(args?: SelectSubset<T, AuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Auth.
     * @param {AuthCreateArgs} args - Arguments to create a Auth.
     * @example
     * // Create one Auth
     * const Auth = await prisma.auth.create({
     *   data: {
     *     // ... data to create a Auth
     *   }
     * })
     * 
     */
    create<T extends AuthCreateArgs>(args: SelectSubset<T, AuthCreateArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Auths.
     * @param {AuthCreateManyArgs} args - Arguments to create many Auths.
     * @example
     * // Create many Auths
     * const auth = await prisma.auth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthCreateManyArgs>(args?: SelectSubset<T, AuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Auth.
     * @param {AuthDeleteArgs} args - Arguments to delete one Auth.
     * @example
     * // Delete one Auth
     * const Auth = await prisma.auth.delete({
     *   where: {
     *     // ... filter to delete one Auth
     *   }
     * })
     * 
     */
    delete<T extends AuthDeleteArgs>(args: SelectSubset<T, AuthDeleteArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Auth.
     * @param {AuthUpdateArgs} args - Arguments to update one Auth.
     * @example
     * // Update one Auth
     * const auth = await prisma.auth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthUpdateArgs>(args: SelectSubset<T, AuthUpdateArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Auths.
     * @param {AuthDeleteManyArgs} args - Arguments to filter Auths to delete.
     * @example
     * // Delete a few Auths
     * const { count } = await prisma.auth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthDeleteManyArgs>(args?: SelectSubset<T, AuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auths
     * const auth = await prisma.auth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthUpdateManyArgs>(args: SelectSubset<T, AuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Auth.
     * @param {AuthUpsertArgs} args - Arguments to update or create a Auth.
     * @example
     * // Update or create a Auth
     * const auth = await prisma.auth.upsert({
     *   create: {
     *     // ... data to create a Auth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auth we want to update
     *   }
     * })
     */
    upsert<T extends AuthUpsertArgs>(args: SelectSubset<T, AuthUpsertArgs<ExtArgs>>): Prisma__AuthClient<$Result.GetResult<Prisma.$AuthPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Auths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthCountArgs} args - Arguments to filter Auths to count.
     * @example
     * // Count the number of Auths
     * const count = await prisma.auth.count({
     *   where: {
     *     // ... the filter for the Auths we want to count
     *   }
     * })
    **/
    count<T extends AuthCountArgs>(
      args?: Subset<T, AuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthAggregateArgs>(args: Subset<T, AuthAggregateArgs>): Prisma.PrismaPromise<GetAuthAggregateType<T>>

    /**
     * Group by Auth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthGroupByArgs['orderBy'] }
        : { orderBy?: AuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auth model
   */
  readonly fields: AuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auth model
   */ 
  interface AuthFieldRefs {
    readonly id: FieldRef<"Auth", 'Int'>
    readonly password: FieldRef<"Auth", 'String'>
    readonly usuarioId: FieldRef<"Auth", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Auth findUnique
   */
  export type AuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth findUniqueOrThrow
   */
  export type AuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth findFirst
   */
  export type AuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auths.
     */
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * Auth findFirstOrThrow
   */
  export type AuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auth to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auths.
     */
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * Auth findMany
   */
  export type AuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter, which Auths to fetch.
     */
    where?: AuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auths to fetch.
     */
    orderBy?: AuthOrderByWithRelationInput | AuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auths.
     */
    cursor?: AuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auths.
     */
    skip?: number
    distinct?: AuthScalarFieldEnum | AuthScalarFieldEnum[]
  }

  /**
   * Auth create
   */
  export type AuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * The data needed to create a Auth.
     */
    data: XOR<AuthCreateInput, AuthUncheckedCreateInput>
  }

  /**
   * Auth createMany
   */
  export type AuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auths.
     */
    data: AuthCreateManyInput | AuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auth update
   */
  export type AuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * The data needed to update a Auth.
     */
    data: XOR<AuthUpdateInput, AuthUncheckedUpdateInput>
    /**
     * Choose, which Auth to update.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth updateMany
   */
  export type AuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auths.
     */
    data: XOR<AuthUpdateManyMutationInput, AuthUncheckedUpdateManyInput>
    /**
     * Filter which Auths to update
     */
    where?: AuthWhereInput
  }

  /**
   * Auth upsert
   */
  export type AuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * The filter to search for the Auth to update in case it exists.
     */
    where: AuthWhereUniqueInput
    /**
     * In case the Auth found by the `where` argument doesn't exist, create a new Auth with this data.
     */
    create: XOR<AuthCreateInput, AuthUncheckedCreateInput>
    /**
     * In case the Auth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthUpdateInput, AuthUncheckedUpdateInput>
  }

  /**
   * Auth delete
   */
  export type AuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
    /**
     * Filter which Auth to delete.
     */
    where: AuthWhereUniqueInput
  }

  /**
   * Auth deleteMany
   */
  export type AuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auths to delete
     */
    where?: AuthWhereInput
  }

  /**
   * Auth without action
   */
  export type AuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auth
     */
    select?: AuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthInclude<ExtArgs> | null
  }


  /**
   * Model Rol
   */

  export type AggregateRol = {
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  export type RolAvgAggregateOutputType = {
    id: number | null
  }

  export type RolSumAggregateOutputType = {
    id: number | null
  }

  export type RolMinAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type RolMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
  }

  export type RolCountAggregateOutputType = {
    id: number
    nombre: number
    _all: number
  }


  export type RolAvgAggregateInputType = {
    id?: true
  }

  export type RolSumAggregateInputType = {
    id?: true
  }

  export type RolMinAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type RolMaxAggregateInputType = {
    id?: true
    nombre?: true
  }

  export type RolCountAggregateInputType = {
    id?: true
    nombre?: true
    _all?: true
  }

  export type RolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rol to aggregate.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rols
    **/
    _count?: true | RolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolMaxAggregateInputType
  }

  export type GetRolAggregateType<T extends RolAggregateArgs> = {
        [P in keyof T & keyof AggregateRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol[P]>
      : GetScalarType<T[P], AggregateRol[P]>
  }




  export type RolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolWhereInput
    orderBy?: RolOrderByWithAggregationInput | RolOrderByWithAggregationInput[]
    by: RolScalarFieldEnum[] | RolScalarFieldEnum
    having?: RolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolCountAggregateInputType | true
    _avg?: RolAvgAggregateInputType
    _sum?: RolSumAggregateInputType
    _min?: RolMinAggregateInputType
    _max?: RolMaxAggregateInputType
  }

  export type RolGroupByOutputType = {
    id: number
    nombre: string
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  type GetRolGroupByPayload<T extends RolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolGroupByOutputType[P]>
            : GetScalarType<T[P], RolGroupByOutputType[P]>
        }
      >
    >


  export type RolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol"]>


  export type RolSelectScalar = {
    id?: boolean
    nombre?: boolean
  }

  export type RolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | Rol$usuariosArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rol"
    objects: {
      usuarios: Prisma.$UsuarioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
    }, ExtArgs["result"]["rol"]>
    composites: {}
  }

  type RolGetPayload<S extends boolean | null | undefined | RolDefaultArgs> = $Result.GetResult<Prisma.$RolPayload, S>

  type RolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolCountAggregateInputType | true
    }

  export interface RolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rol'], meta: { name: 'Rol' } }
    /**
     * Find zero or one Rol that matches the filter.
     * @param {RolFindUniqueArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolFindUniqueArgs>(args: SelectSubset<T, RolFindUniqueArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolFindUniqueOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolFindUniqueOrThrowArgs>(args: SelectSubset<T, RolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolFindFirstArgs>(args?: SelectSubset<T, RolFindFirstArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolFindFirstOrThrowArgs>(args?: SelectSubset<T, RolFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rols
     * const rols = await prisma.rol.findMany()
     * 
     * // Get first 10 Rols
     * const rols = await prisma.rol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolWithIdOnly = await prisma.rol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolFindManyArgs>(args?: SelectSubset<T, RolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rol.
     * @param {RolCreateArgs} args - Arguments to create a Rol.
     * @example
     * // Create one Rol
     * const Rol = await prisma.rol.create({
     *   data: {
     *     // ... data to create a Rol
     *   }
     * })
     * 
     */
    create<T extends RolCreateArgs>(args: SelectSubset<T, RolCreateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rols.
     * @param {RolCreateManyArgs} args - Arguments to create many Rols.
     * @example
     * // Create many Rols
     * const rol = await prisma.rol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolCreateManyArgs>(args?: SelectSubset<T, RolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rol.
     * @param {RolDeleteArgs} args - Arguments to delete one Rol.
     * @example
     * // Delete one Rol
     * const Rol = await prisma.rol.delete({
     *   where: {
     *     // ... filter to delete one Rol
     *   }
     * })
     * 
     */
    delete<T extends RolDeleteArgs>(args: SelectSubset<T, RolDeleteArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rol.
     * @param {RolUpdateArgs} args - Arguments to update one Rol.
     * @example
     * // Update one Rol
     * const rol = await prisma.rol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolUpdateArgs>(args: SelectSubset<T, RolUpdateArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rols.
     * @param {RolDeleteManyArgs} args - Arguments to filter Rols to delete.
     * @example
     * // Delete a few Rols
     * const { count } = await prisma.rol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolDeleteManyArgs>(args?: SelectSubset<T, RolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolUpdateManyArgs>(args: SelectSubset<T, RolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rol.
     * @param {RolUpsertArgs} args - Arguments to update or create a Rol.
     * @example
     * // Update or create a Rol
     * const rol = await prisma.rol.upsert({
     *   create: {
     *     // ... data to create a Rol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol we want to update
     *   }
     * })
     */
    upsert<T extends RolUpsertArgs>(args: SelectSubset<T, RolUpsertArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolCountArgs} args - Arguments to filter Rols to count.
     * @example
     * // Count the number of Rols
     * const count = await prisma.rol.count({
     *   where: {
     *     // ... the filter for the Rols we want to count
     *   }
     * })
    **/
    count<T extends RolCountArgs>(
      args?: Subset<T, RolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolAggregateArgs>(args: Subset<T, RolAggregateArgs>): Prisma.PrismaPromise<GetRolAggregateType<T>>

    /**
     * Group by Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolGroupByArgs['orderBy'] }
        : { orderBy?: RolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rol model
   */
  readonly fields: RolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios<T extends Rol$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, Rol$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rol model
   */ 
  interface RolFieldRefs {
    readonly id: FieldRef<"Rol", 'Int'>
    readonly nombre: FieldRef<"Rol", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Rol findUnique
   */
  export type RolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findUniqueOrThrow
   */
  export type RolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol findFirst
   */
  export type RolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findFirstOrThrow
   */
  export type RolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol findMany
   */
  export type RolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rols to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }

  /**
   * Rol create
   */
  export type RolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to create a Rol.
     */
    data: XOR<RolCreateInput, RolUncheckedCreateInput>
  }

  /**
   * Rol createMany
   */
  export type RolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rol update
   */
  export type RolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to update a Rol.
     */
    data: XOR<RolUpdateInput, RolUncheckedUpdateInput>
    /**
     * Choose, which Rol to update.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol updateMany
   */
  export type RolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
  }

  /**
   * Rol upsert
   */
  export type RolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The filter to search for the Rol to update in case it exists.
     */
    where: RolWhereUniqueInput
    /**
     * In case the Rol found by the `where` argument doesn't exist, create a new Rol with this data.
     */
    create: XOR<RolCreateInput, RolUncheckedCreateInput>
    /**
     * In case the Rol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolUpdateInput, RolUncheckedUpdateInput>
  }

  /**
   * Rol delete
   */
  export type RolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter which Rol to delete.
     */
    where: RolWhereUniqueInput
  }

  /**
   * Rol deleteMany
   */
  export type RolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rols to delete
     */
    where?: RolWhereInput
  }

  /**
   * Rol.usuarios
   */
  export type Rol$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Rol without action
   */
  export type RolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolInclude<ExtArgs> | null
  }


  /**
   * Model Categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    id?: true
  }

  export type CategoriaSumAggregateInputType = {
    id?: true
  }

  export type CategoriaMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type CategoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type CategoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categoria to aggregate.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type CategoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoriaWhereInput
    orderBy?: CategoriaOrderByWithAggregationInput | CategoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: CategoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends CategoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type CategoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    emprendimientos?: boolean | Categoria$emprendimientosArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>


  export type CategoriaSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type CategoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimientos?: boolean | Categoria$emprendimientosArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Categoria"
    objects: {
      emprendimientos: Prisma.$EmprendimientoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }

  type CategoriaGetPayload<S extends boolean | null | undefined | CategoriaDefaultArgs> = $Result.GetResult<Prisma.$CategoriaPayload, S>

  type CategoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface CategoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Categoria'], meta: { name: 'Categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {CategoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoriaFindUniqueArgs>(args: SelectSubset<T, CategoriaFindUniqueArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Categoria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoriaFindFirstArgs>(args?: SelectSubset<T, CategoriaFindFirstArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriaWithIdOnly = await prisma.categoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoriaFindManyArgs>(args?: SelectSubset<T, CategoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Categoria.
     * @param {CategoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
     */
    create<T extends CategoriaCreateArgs>(args: SelectSubset<T, CategoriaCreateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categorias.
     * @param {CategoriaCreateManyArgs} args - Arguments to create many Categorias.
     * @example
     * // Create many Categorias
     * const categoria = await prisma.categoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoriaCreateManyArgs>(args?: SelectSubset<T, CategoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria.
     * @param {CategoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
     */
    delete<T extends CategoriaDeleteArgs>(args: SelectSubset<T, CategoriaDeleteArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Categoria.
     * @param {CategoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoriaUpdateArgs>(args: SelectSubset<T, CategoriaUpdateArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categorias.
     * @param {CategoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoriaDeleteManyArgs>(args?: SelectSubset<T, CategoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoriaUpdateManyArgs>(args: SelectSubset<T, CategoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria.
     * @param {CategoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
     */
    upsert<T extends CategoriaUpsertArgs>(args: SelectSubset<T, CategoriaUpsertArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends CategoriaCountArgs>(
      args?: Subset<T, CategoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoriaGroupByArgs['orderBy'] }
        : { orderBy?: CategoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Categoria model
   */
  readonly fields: CategoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emprendimientos<T extends Categoria$emprendimientosArgs<ExtArgs> = {}>(args?: Subset<T, Categoria$emprendimientosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Categoria model
   */ 
  interface CategoriaFieldRefs {
    readonly id: FieldRef<"Categoria", 'Int'>
    readonly nombre: FieldRef<"Categoria", 'String'>
    readonly descripcion: FieldRef<"Categoria", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Categoria findUnique
   */
  export type CategoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findUniqueOrThrow
   */
  export type CategoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria findFirst
   */
  export type CategoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findFirstOrThrow
   */
  export type CategoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categoria to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria findMany
   */
  export type CategoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter, which Categorias to fetch.
     */
    where?: CategoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categorias to fetch.
     */
    orderBy?: CategoriaOrderByWithRelationInput | CategoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categorias.
     */
    cursor?: CategoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }

  /**
   * Categoria create
   */
  export type CategoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Categoria.
     */
    data: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
  }

  /**
   * Categoria createMany
   */
  export type CategoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categorias.
     */
    data: CategoriaCreateManyInput | CategoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Categoria update
   */
  export type CategoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Categoria.
     */
    data: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
    /**
     * Choose, which Categoria to update.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria updateMany
   */
  export type CategoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categorias.
     */
    data: XOR<CategoriaUpdateManyMutationInput, CategoriaUncheckedUpdateManyInput>
    /**
     * Filter which Categorias to update
     */
    where?: CategoriaWhereInput
  }

  /**
   * Categoria upsert
   */
  export type CategoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Categoria to update in case it exists.
     */
    where: CategoriaWhereUniqueInput
    /**
     * In case the Categoria found by the `where` argument doesn't exist, create a new Categoria with this data.
     */
    create: XOR<CategoriaCreateInput, CategoriaUncheckedCreateInput>
    /**
     * In case the Categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoriaUpdateInput, CategoriaUncheckedUpdateInput>
  }

  /**
   * Categoria delete
   */
  export type CategoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
    /**
     * Filter which Categoria to delete.
     */
    where: CategoriaWhereUniqueInput
  }

  /**
   * Categoria deleteMany
   */
  export type CategoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categorias to delete
     */
    where?: CategoriaWhereInput
  }

  /**
   * Categoria.emprendimientos
   */
  export type Categoria$emprendimientosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    where?: EmprendimientoWhereInput
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    cursor?: EmprendimientoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Categoria without action
   */
  export type CategoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Categoria
     */
    select?: CategoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoriaInclude<ExtArgs> | null
  }


  /**
   * Model Emprendimiento
   */

  export type AggregateEmprendimiento = {
    _count: EmprendimientoCountAggregateOutputType | null
    _avg: EmprendimientoAvgAggregateOutputType | null
    _sum: EmprendimientoSumAggregateOutputType | null
    _min: EmprendimientoMinAggregateOutputType | null
    _max: EmprendimientoMaxAggregateOutputType | null
  }

  export type EmprendimientoAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    categoriaId: number | null
  }

  export type EmprendimientoSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    categoriaId: number | null
  }

  export type EmprendimientoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    logoUrl: string | null
    fechaCreacion: Date | null
    estado: $Enums.EstadoEmprendimiento | null
    usuarioId: number | null
    categoriaId: number | null
  }

  export type EmprendimientoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    logoUrl: string | null
    fechaCreacion: Date | null
    estado: $Enums.EstadoEmprendimiento | null
    usuarioId: number | null
    categoriaId: number | null
  }

  export type EmprendimientoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    logoUrl: number
    fechaCreacion: number
    estado: number
    usuarioId: number
    categoriaId: number
    _all: number
  }


  export type EmprendimientoAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    categoriaId?: true
  }

  export type EmprendimientoSumAggregateInputType = {
    id?: true
    usuarioId?: true
    categoriaId?: true
  }

  export type EmprendimientoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    logoUrl?: true
    fechaCreacion?: true
    estado?: true
    usuarioId?: true
    categoriaId?: true
  }

  export type EmprendimientoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    logoUrl?: true
    fechaCreacion?: true
    estado?: true
    usuarioId?: true
    categoriaId?: true
  }

  export type EmprendimientoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    logoUrl?: true
    fechaCreacion?: true
    estado?: true
    usuarioId?: true
    categoriaId?: true
    _all?: true
  }

  export type EmprendimientoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emprendimiento to aggregate.
     */
    where?: EmprendimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprendimientos to fetch.
     */
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmprendimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprendimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprendimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emprendimientos
    **/
    _count?: true | EmprendimientoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmprendimientoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmprendimientoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmprendimientoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmprendimientoMaxAggregateInputType
  }

  export type GetEmprendimientoAggregateType<T extends EmprendimientoAggregateArgs> = {
        [P in keyof T & keyof AggregateEmprendimiento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmprendimiento[P]>
      : GetScalarType<T[P], AggregateEmprendimiento[P]>
  }




  export type EmprendimientoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmprendimientoWhereInput
    orderBy?: EmprendimientoOrderByWithAggregationInput | EmprendimientoOrderByWithAggregationInput[]
    by: EmprendimientoScalarFieldEnum[] | EmprendimientoScalarFieldEnum
    having?: EmprendimientoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmprendimientoCountAggregateInputType | true
    _avg?: EmprendimientoAvgAggregateInputType
    _sum?: EmprendimientoSumAggregateInputType
    _min?: EmprendimientoMinAggregateInputType
    _max?: EmprendimientoMaxAggregateInputType
  }

  export type EmprendimientoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    logoUrl: string | null
    fechaCreacion: Date
    estado: $Enums.EstadoEmprendimiento
    usuarioId: number
    categoriaId: number
    _count: EmprendimientoCountAggregateOutputType | null
    _avg: EmprendimientoAvgAggregateOutputType | null
    _sum: EmprendimientoSumAggregateOutputType | null
    _min: EmprendimientoMinAggregateOutputType | null
    _max: EmprendimientoMaxAggregateOutputType | null
  }

  type GetEmprendimientoGroupByPayload<T extends EmprendimientoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmprendimientoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmprendimientoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmprendimientoGroupByOutputType[P]>
            : GetScalarType<T[P], EmprendimientoGroupByOutputType[P]>
        }
      >
    >


  export type EmprendimientoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    logoUrl?: boolean
    fechaCreacion?: boolean
    estado?: boolean
    usuarioId?: boolean
    categoriaId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    productos?: boolean | Emprendimiento$productosArgs<ExtArgs>
    redesSociales?: boolean | Emprendimiento$redesSocialesArgs<ExtArgs>
    mentorias?: boolean | Emprendimiento$mentoriasArgs<ExtArgs>
    resenas?: boolean | Emprendimiento$resenasArgs<ExtArgs>
    promociones?: boolean | Emprendimiento$promocionesArgs<ExtArgs>
    _count?: boolean | EmprendimientoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emprendimiento"]>


  export type EmprendimientoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    logoUrl?: boolean
    fechaCreacion?: boolean
    estado?: boolean
    usuarioId?: boolean
    categoriaId?: boolean
  }

  export type EmprendimientoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    categoria?: boolean | CategoriaDefaultArgs<ExtArgs>
    productos?: boolean | Emprendimiento$productosArgs<ExtArgs>
    redesSociales?: boolean | Emprendimiento$redesSocialesArgs<ExtArgs>
    mentorias?: boolean | Emprendimiento$mentoriasArgs<ExtArgs>
    resenas?: boolean | Emprendimiento$resenasArgs<ExtArgs>
    promociones?: boolean | Emprendimiento$promocionesArgs<ExtArgs>
    _count?: boolean | EmprendimientoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmprendimientoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Emprendimiento"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      categoria: Prisma.$CategoriaPayload<ExtArgs>
      productos: Prisma.$ProductoPayload<ExtArgs>[]
      redesSociales: Prisma.$RedesSocialesPayload<ExtArgs> | null
      mentorias: Prisma.$MentoriaPayload<ExtArgs>[]
      resenas: Prisma.$ResenaPayload<ExtArgs>[]
      promociones: Prisma.$PromocionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      logoUrl: string | null
      fechaCreacion: Date
      estado: $Enums.EstadoEmprendimiento
      usuarioId: number
      categoriaId: number
    }, ExtArgs["result"]["emprendimiento"]>
    composites: {}
  }

  type EmprendimientoGetPayload<S extends boolean | null | undefined | EmprendimientoDefaultArgs> = $Result.GetResult<Prisma.$EmprendimientoPayload, S>

  type EmprendimientoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmprendimientoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmprendimientoCountAggregateInputType | true
    }

  export interface EmprendimientoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Emprendimiento'], meta: { name: 'Emprendimiento' } }
    /**
     * Find zero or one Emprendimiento that matches the filter.
     * @param {EmprendimientoFindUniqueArgs} args - Arguments to find a Emprendimiento
     * @example
     * // Get one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmprendimientoFindUniqueArgs>(args: SelectSubset<T, EmprendimientoFindUniqueArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Emprendimiento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmprendimientoFindUniqueOrThrowArgs} args - Arguments to find a Emprendimiento
     * @example
     * // Get one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmprendimientoFindUniqueOrThrowArgs>(args: SelectSubset<T, EmprendimientoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Emprendimiento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoFindFirstArgs} args - Arguments to find a Emprendimiento
     * @example
     * // Get one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmprendimientoFindFirstArgs>(args?: SelectSubset<T, EmprendimientoFindFirstArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Emprendimiento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoFindFirstOrThrowArgs} args - Arguments to find a Emprendimiento
     * @example
     * // Get one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmprendimientoFindFirstOrThrowArgs>(args?: SelectSubset<T, EmprendimientoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Emprendimientos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emprendimientos
     * const emprendimientos = await prisma.emprendimiento.findMany()
     * 
     * // Get first 10 Emprendimientos
     * const emprendimientos = await prisma.emprendimiento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emprendimientoWithIdOnly = await prisma.emprendimiento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmprendimientoFindManyArgs>(args?: SelectSubset<T, EmprendimientoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Emprendimiento.
     * @param {EmprendimientoCreateArgs} args - Arguments to create a Emprendimiento.
     * @example
     * // Create one Emprendimiento
     * const Emprendimiento = await prisma.emprendimiento.create({
     *   data: {
     *     // ... data to create a Emprendimiento
     *   }
     * })
     * 
     */
    create<T extends EmprendimientoCreateArgs>(args: SelectSubset<T, EmprendimientoCreateArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Emprendimientos.
     * @param {EmprendimientoCreateManyArgs} args - Arguments to create many Emprendimientos.
     * @example
     * // Create many Emprendimientos
     * const emprendimiento = await prisma.emprendimiento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmprendimientoCreateManyArgs>(args?: SelectSubset<T, EmprendimientoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Emprendimiento.
     * @param {EmprendimientoDeleteArgs} args - Arguments to delete one Emprendimiento.
     * @example
     * // Delete one Emprendimiento
     * const Emprendimiento = await prisma.emprendimiento.delete({
     *   where: {
     *     // ... filter to delete one Emprendimiento
     *   }
     * })
     * 
     */
    delete<T extends EmprendimientoDeleteArgs>(args: SelectSubset<T, EmprendimientoDeleteArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Emprendimiento.
     * @param {EmprendimientoUpdateArgs} args - Arguments to update one Emprendimiento.
     * @example
     * // Update one Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmprendimientoUpdateArgs>(args: SelectSubset<T, EmprendimientoUpdateArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Emprendimientos.
     * @param {EmprendimientoDeleteManyArgs} args - Arguments to filter Emprendimientos to delete.
     * @example
     * // Delete a few Emprendimientos
     * const { count } = await prisma.emprendimiento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmprendimientoDeleteManyArgs>(args?: SelectSubset<T, EmprendimientoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emprendimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emprendimientos
     * const emprendimiento = await prisma.emprendimiento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmprendimientoUpdateManyArgs>(args: SelectSubset<T, EmprendimientoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Emprendimiento.
     * @param {EmprendimientoUpsertArgs} args - Arguments to update or create a Emprendimiento.
     * @example
     * // Update or create a Emprendimiento
     * const emprendimiento = await prisma.emprendimiento.upsert({
     *   create: {
     *     // ... data to create a Emprendimiento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emprendimiento we want to update
     *   }
     * })
     */
    upsert<T extends EmprendimientoUpsertArgs>(args: SelectSubset<T, EmprendimientoUpsertArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Emprendimientos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoCountArgs} args - Arguments to filter Emprendimientos to count.
     * @example
     * // Count the number of Emprendimientos
     * const count = await prisma.emprendimiento.count({
     *   where: {
     *     // ... the filter for the Emprendimientos we want to count
     *   }
     * })
    **/
    count<T extends EmprendimientoCountArgs>(
      args?: Subset<T, EmprendimientoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmprendimientoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emprendimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmprendimientoAggregateArgs>(args: Subset<T, EmprendimientoAggregateArgs>): Prisma.PrismaPromise<GetEmprendimientoAggregateType<T>>

    /**
     * Group by Emprendimiento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmprendimientoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmprendimientoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmprendimientoGroupByArgs['orderBy'] }
        : { orderBy?: EmprendimientoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmprendimientoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmprendimientoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Emprendimiento model
   */
  readonly fields: EmprendimientoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Emprendimiento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmprendimientoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    categoria<T extends CategoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoriaDefaultArgs<ExtArgs>>): Prisma__CategoriaClient<$Result.GetResult<Prisma.$CategoriaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    productos<T extends Emprendimiento$productosArgs<ExtArgs> = {}>(args?: Subset<T, Emprendimiento$productosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findMany"> | Null>
    redesSociales<T extends Emprendimiento$redesSocialesArgs<ExtArgs> = {}>(args?: Subset<T, Emprendimiento$redesSocialesArgs<ExtArgs>>): Prisma__RedesSocialesClient<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    mentorias<T extends Emprendimiento$mentoriasArgs<ExtArgs> = {}>(args?: Subset<T, Emprendimiento$mentoriasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "findMany"> | Null>
    resenas<T extends Emprendimiento$resenasArgs<ExtArgs> = {}>(args?: Subset<T, Emprendimiento$resenasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findMany"> | Null>
    promociones<T extends Emprendimiento$promocionesArgs<ExtArgs> = {}>(args?: Subset<T, Emprendimiento$promocionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Emprendimiento model
   */ 
  interface EmprendimientoFieldRefs {
    readonly id: FieldRef<"Emprendimiento", 'Int'>
    readonly nombre: FieldRef<"Emprendimiento", 'String'>
    readonly descripcion: FieldRef<"Emprendimiento", 'String'>
    readonly logoUrl: FieldRef<"Emprendimiento", 'String'>
    readonly fechaCreacion: FieldRef<"Emprendimiento", 'DateTime'>
    readonly estado: FieldRef<"Emprendimiento", 'EstadoEmprendimiento'>
    readonly usuarioId: FieldRef<"Emprendimiento", 'Int'>
    readonly categoriaId: FieldRef<"Emprendimiento", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Emprendimiento findUnique
   */
  export type EmprendimientoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimiento to fetch.
     */
    where: EmprendimientoWhereUniqueInput
  }

  /**
   * Emprendimiento findUniqueOrThrow
   */
  export type EmprendimientoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimiento to fetch.
     */
    where: EmprendimientoWhereUniqueInput
  }

  /**
   * Emprendimiento findFirst
   */
  export type EmprendimientoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimiento to fetch.
     */
    where?: EmprendimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprendimientos to fetch.
     */
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emprendimientos.
     */
    cursor?: EmprendimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprendimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprendimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emprendimientos.
     */
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Emprendimiento findFirstOrThrow
   */
  export type EmprendimientoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimiento to fetch.
     */
    where?: EmprendimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprendimientos to fetch.
     */
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emprendimientos.
     */
    cursor?: EmprendimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprendimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprendimientos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emprendimientos.
     */
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Emprendimiento findMany
   */
  export type EmprendimientoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter, which Emprendimientos to fetch.
     */
    where?: EmprendimientoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emprendimientos to fetch.
     */
    orderBy?: EmprendimientoOrderByWithRelationInput | EmprendimientoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emprendimientos.
     */
    cursor?: EmprendimientoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emprendimientos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emprendimientos.
     */
    skip?: number
    distinct?: EmprendimientoScalarFieldEnum | EmprendimientoScalarFieldEnum[]
  }

  /**
   * Emprendimiento create
   */
  export type EmprendimientoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * The data needed to create a Emprendimiento.
     */
    data: XOR<EmprendimientoCreateInput, EmprendimientoUncheckedCreateInput>
  }

  /**
   * Emprendimiento createMany
   */
  export type EmprendimientoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emprendimientos.
     */
    data: EmprendimientoCreateManyInput | EmprendimientoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Emprendimiento update
   */
  export type EmprendimientoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * The data needed to update a Emprendimiento.
     */
    data: XOR<EmprendimientoUpdateInput, EmprendimientoUncheckedUpdateInput>
    /**
     * Choose, which Emprendimiento to update.
     */
    where: EmprendimientoWhereUniqueInput
  }

  /**
   * Emprendimiento updateMany
   */
  export type EmprendimientoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emprendimientos.
     */
    data: XOR<EmprendimientoUpdateManyMutationInput, EmprendimientoUncheckedUpdateManyInput>
    /**
     * Filter which Emprendimientos to update
     */
    where?: EmprendimientoWhereInput
  }

  /**
   * Emprendimiento upsert
   */
  export type EmprendimientoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * The filter to search for the Emprendimiento to update in case it exists.
     */
    where: EmprendimientoWhereUniqueInput
    /**
     * In case the Emprendimiento found by the `where` argument doesn't exist, create a new Emprendimiento with this data.
     */
    create: XOR<EmprendimientoCreateInput, EmprendimientoUncheckedCreateInput>
    /**
     * In case the Emprendimiento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmprendimientoUpdateInput, EmprendimientoUncheckedUpdateInput>
  }

  /**
   * Emprendimiento delete
   */
  export type EmprendimientoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
    /**
     * Filter which Emprendimiento to delete.
     */
    where: EmprendimientoWhereUniqueInput
  }

  /**
   * Emprendimiento deleteMany
   */
  export type EmprendimientoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emprendimientos to delete
     */
    where?: EmprendimientoWhereInput
  }

  /**
   * Emprendimiento.productos
   */
  export type Emprendimiento$productosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    cursor?: ProductoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Emprendimiento.redesSociales
   */
  export type Emprendimiento$redesSocialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    where?: RedesSocialesWhereInput
  }

  /**
   * Emprendimiento.mentorias
   */
  export type Emprendimiento$mentoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    where?: MentoriaWhereInput
    orderBy?: MentoriaOrderByWithRelationInput | MentoriaOrderByWithRelationInput[]
    cursor?: MentoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentoriaScalarFieldEnum | MentoriaScalarFieldEnum[]
  }

  /**
   * Emprendimiento.resenas
   */
  export type Emprendimiento$resenasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    where?: ResenaWhereInput
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    cursor?: ResenaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Emprendimiento.promociones
   */
  export type Emprendimiento$promocionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    where?: PromocionWhereInput
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    cursor?: PromocionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromocionScalarFieldEnum | PromocionScalarFieldEnum[]
  }

  /**
   * Emprendimiento without action
   */
  export type EmprendimientoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emprendimiento
     */
    select?: EmprendimientoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmprendimientoInclude<ExtArgs> | null
  }


  /**
   * Model Producto
   */

  export type AggregateProducto = {
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  export type ProductoAvgAggregateOutputType = {
    id: number | null
    precio: Decimal | null
    emprendimientoId: number | null
  }

  export type ProductoSumAggregateOutputType = {
    id: number | null
    precio: Decimal | null
    emprendimientoId: number | null
  }

  export type ProductoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    precio: Decimal | null
    imagenUrl: string | null
    activo: boolean | null
    emprendimientoId: number | null
  }

  export type ProductoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    precio: Decimal | null
    imagenUrl: string | null
    activo: boolean | null
    emprendimientoId: number | null
  }

  export type ProductoCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    precio: number
    imagenUrl: number
    activo: number
    emprendimientoId: number
    _all: number
  }


  export type ProductoAvgAggregateInputType = {
    id?: true
    precio?: true
    emprendimientoId?: true
  }

  export type ProductoSumAggregateInputType = {
    id?: true
    precio?: true
    emprendimientoId?: true
  }

  export type ProductoMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    precio?: true
    imagenUrl?: true
    activo?: true
    emprendimientoId?: true
  }

  export type ProductoMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    precio?: true
    imagenUrl?: true
    activo?: true
    emprendimientoId?: true
  }

  export type ProductoCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    precio?: true
    imagenUrl?: true
    activo?: true
    emprendimientoId?: true
    _all?: true
  }

  export type ProductoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Producto to aggregate.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Productos
    **/
    _count?: true | ProductoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductoMaxAggregateInputType
  }

  export type GetProductoAggregateType<T extends ProductoAggregateArgs> = {
        [P in keyof T & keyof AggregateProducto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducto[P]>
      : GetScalarType<T[P], AggregateProducto[P]>
  }




  export type ProductoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductoWhereInput
    orderBy?: ProductoOrderByWithAggregationInput | ProductoOrderByWithAggregationInput[]
    by: ProductoScalarFieldEnum[] | ProductoScalarFieldEnum
    having?: ProductoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductoCountAggregateInputType | true
    _avg?: ProductoAvgAggregateInputType
    _sum?: ProductoSumAggregateInputType
    _min?: ProductoMinAggregateInputType
    _max?: ProductoMaxAggregateInputType
  }

  export type ProductoGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    precio: Decimal
    imagenUrl: string | null
    activo: boolean
    emprendimientoId: number
    _count: ProductoCountAggregateOutputType | null
    _avg: ProductoAvgAggregateOutputType | null
    _sum: ProductoSumAggregateOutputType | null
    _min: ProductoMinAggregateOutputType | null
    _max: ProductoMaxAggregateOutputType | null
  }

  type GetProductoGroupByPayload<T extends ProductoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductoGroupByOutputType[P]>
            : GetScalarType<T[P], ProductoGroupByOutputType[P]>
        }
      >
    >


  export type ProductoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio?: boolean
    imagenUrl?: boolean
    activo?: boolean
    emprendimientoId?: boolean
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["producto"]>


  export type ProductoSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    precio?: boolean
    imagenUrl?: boolean
    activo?: boolean
    emprendimientoId?: boolean
  }

  export type ProductoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }

  export type $ProductoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Producto"
    objects: {
      emprendimiento: Prisma.$EmprendimientoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      precio: Prisma.Decimal
      imagenUrl: string | null
      activo: boolean
      emprendimientoId: number
    }, ExtArgs["result"]["producto"]>
    composites: {}
  }

  type ProductoGetPayload<S extends boolean | null | undefined | ProductoDefaultArgs> = $Result.GetResult<Prisma.$ProductoPayload, S>

  type ProductoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductoCountAggregateInputType | true
    }

  export interface ProductoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Producto'], meta: { name: 'Producto' } }
    /**
     * Find zero or one Producto that matches the filter.
     * @param {ProductoFindUniqueArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductoFindUniqueArgs>(args: SelectSubset<T, ProductoFindUniqueArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Producto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductoFindUniqueOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Producto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductoFindFirstArgs>(args?: SelectSubset<T, ProductoFindFirstArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Producto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindFirstOrThrowArgs} args - Arguments to find a Producto
     * @example
     * // Get one Producto
     * const producto = await prisma.producto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Productos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Productos
     * const productos = await prisma.producto.findMany()
     * 
     * // Get first 10 Productos
     * const productos = await prisma.producto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productoWithIdOnly = await prisma.producto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductoFindManyArgs>(args?: SelectSubset<T, ProductoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Producto.
     * @param {ProductoCreateArgs} args - Arguments to create a Producto.
     * @example
     * // Create one Producto
     * const Producto = await prisma.producto.create({
     *   data: {
     *     // ... data to create a Producto
     *   }
     * })
     * 
     */
    create<T extends ProductoCreateArgs>(args: SelectSubset<T, ProductoCreateArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Productos.
     * @param {ProductoCreateManyArgs} args - Arguments to create many Productos.
     * @example
     * // Create many Productos
     * const producto = await prisma.producto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductoCreateManyArgs>(args?: SelectSubset<T, ProductoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Producto.
     * @param {ProductoDeleteArgs} args - Arguments to delete one Producto.
     * @example
     * // Delete one Producto
     * const Producto = await prisma.producto.delete({
     *   where: {
     *     // ... filter to delete one Producto
     *   }
     * })
     * 
     */
    delete<T extends ProductoDeleteArgs>(args: SelectSubset<T, ProductoDeleteArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Producto.
     * @param {ProductoUpdateArgs} args - Arguments to update one Producto.
     * @example
     * // Update one Producto
     * const producto = await prisma.producto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductoUpdateArgs>(args: SelectSubset<T, ProductoUpdateArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Productos.
     * @param {ProductoDeleteManyArgs} args - Arguments to filter Productos to delete.
     * @example
     * // Delete a few Productos
     * const { count } = await prisma.producto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductoDeleteManyArgs>(args?: SelectSubset<T, ProductoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Productos
     * const producto = await prisma.producto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductoUpdateManyArgs>(args: SelectSubset<T, ProductoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Producto.
     * @param {ProductoUpsertArgs} args - Arguments to update or create a Producto.
     * @example
     * // Update or create a Producto
     * const producto = await prisma.producto.upsert({
     *   create: {
     *     // ... data to create a Producto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Producto we want to update
     *   }
     * })
     */
    upsert<T extends ProductoUpsertArgs>(args: SelectSubset<T, ProductoUpsertArgs<ExtArgs>>): Prisma__ProductoClient<$Result.GetResult<Prisma.$ProductoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Productos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoCountArgs} args - Arguments to filter Productos to count.
     * @example
     * // Count the number of Productos
     * const count = await prisma.producto.count({
     *   where: {
     *     // ... the filter for the Productos we want to count
     *   }
     * })
    **/
    count<T extends ProductoCountArgs>(
      args?: Subset<T, ProductoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductoAggregateArgs>(args: Subset<T, ProductoAggregateArgs>): Prisma.PrismaPromise<GetProductoAggregateType<T>>

    /**
     * Group by Producto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductoGroupByArgs['orderBy'] }
        : { orderBy?: ProductoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Producto model
   */
  readonly fields: ProductoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Producto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emprendimiento<T extends EmprendimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmprendimientoDefaultArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Producto model
   */ 
  interface ProductoFieldRefs {
    readonly id: FieldRef<"Producto", 'Int'>
    readonly nombre: FieldRef<"Producto", 'String'>
    readonly descripcion: FieldRef<"Producto", 'String'>
    readonly precio: FieldRef<"Producto", 'Decimal'>
    readonly imagenUrl: FieldRef<"Producto", 'String'>
    readonly activo: FieldRef<"Producto", 'Boolean'>
    readonly emprendimientoId: FieldRef<"Producto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Producto findUnique
   */
  export type ProductoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto findUniqueOrThrow
   */
  export type ProductoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto findFirst
   */
  export type ProductoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto findFirstOrThrow
   */
  export type ProductoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Producto to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Productos.
     */
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto findMany
   */
  export type ProductoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter, which Productos to fetch.
     */
    where?: ProductoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Productos to fetch.
     */
    orderBy?: ProductoOrderByWithRelationInput | ProductoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Productos.
     */
    cursor?: ProductoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Productos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Productos.
     */
    skip?: number
    distinct?: ProductoScalarFieldEnum | ProductoScalarFieldEnum[]
  }

  /**
   * Producto create
   */
  export type ProductoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to create a Producto.
     */
    data: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
  }

  /**
   * Producto createMany
   */
  export type ProductoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Productos.
     */
    data: ProductoCreateManyInput | ProductoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Producto update
   */
  export type ProductoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The data needed to update a Producto.
     */
    data: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
    /**
     * Choose, which Producto to update.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto updateMany
   */
  export type ProductoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Productos.
     */
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyInput>
    /**
     * Filter which Productos to update
     */
    where?: ProductoWhereInput
  }

  /**
   * Producto upsert
   */
  export type ProductoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * The filter to search for the Producto to update in case it exists.
     */
    where: ProductoWhereUniqueInput
    /**
     * In case the Producto found by the `where` argument doesn't exist, create a new Producto with this data.
     */
    create: XOR<ProductoCreateInput, ProductoUncheckedCreateInput>
    /**
     * In case the Producto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductoUpdateInput, ProductoUncheckedUpdateInput>
  }

  /**
   * Producto delete
   */
  export type ProductoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
    /**
     * Filter which Producto to delete.
     */
    where: ProductoWhereUniqueInput
  }

  /**
   * Producto deleteMany
   */
  export type ProductoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Productos to delete
     */
    where?: ProductoWhereInput
  }

  /**
   * Producto without action
   */
  export type ProductoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Producto
     */
    select?: ProductoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductoInclude<ExtArgs> | null
  }


  /**
   * Model RedesSociales
   */

  export type AggregateRedesSociales = {
    _count: RedesSocialesCountAggregateOutputType | null
    _avg: RedesSocialesAvgAggregateOutputType | null
    _sum: RedesSocialesSumAggregateOutputType | null
    _min: RedesSocialesMinAggregateOutputType | null
    _max: RedesSocialesMaxAggregateOutputType | null
  }

  export type RedesSocialesAvgAggregateOutputType = {
    id: number | null
    emprendimientoId: number | null
  }

  export type RedesSocialesSumAggregateOutputType = {
    id: number | null
    emprendimientoId: number | null
  }

  export type RedesSocialesMinAggregateOutputType = {
    id: number | null
    instagram: string | null
    facebook: string | null
    tiktok: string | null
    whatsapp: string | null
    website: string | null
    emprendimientoId: number | null
  }

  export type RedesSocialesMaxAggregateOutputType = {
    id: number | null
    instagram: string | null
    facebook: string | null
    tiktok: string | null
    whatsapp: string | null
    website: string | null
    emprendimientoId: number | null
  }

  export type RedesSocialesCountAggregateOutputType = {
    id: number
    instagram: number
    facebook: number
    tiktok: number
    whatsapp: number
    website: number
    emprendimientoId: number
    _all: number
  }


  export type RedesSocialesAvgAggregateInputType = {
    id?: true
    emprendimientoId?: true
  }

  export type RedesSocialesSumAggregateInputType = {
    id?: true
    emprendimientoId?: true
  }

  export type RedesSocialesMinAggregateInputType = {
    id?: true
    instagram?: true
    facebook?: true
    tiktok?: true
    whatsapp?: true
    website?: true
    emprendimientoId?: true
  }

  export type RedesSocialesMaxAggregateInputType = {
    id?: true
    instagram?: true
    facebook?: true
    tiktok?: true
    whatsapp?: true
    website?: true
    emprendimientoId?: true
  }

  export type RedesSocialesCountAggregateInputType = {
    id?: true
    instagram?: true
    facebook?: true
    tiktok?: true
    whatsapp?: true
    website?: true
    emprendimientoId?: true
    _all?: true
  }

  export type RedesSocialesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedesSociales to aggregate.
     */
    where?: RedesSocialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedesSociales to fetch.
     */
    orderBy?: RedesSocialesOrderByWithRelationInput | RedesSocialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedesSocialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedesSociales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedesSociales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RedesSociales
    **/
    _count?: true | RedesSocialesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedesSocialesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedesSocialesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedesSocialesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedesSocialesMaxAggregateInputType
  }

  export type GetRedesSocialesAggregateType<T extends RedesSocialesAggregateArgs> = {
        [P in keyof T & keyof AggregateRedesSociales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedesSociales[P]>
      : GetScalarType<T[P], AggregateRedesSociales[P]>
  }




  export type RedesSocialesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedesSocialesWhereInput
    orderBy?: RedesSocialesOrderByWithAggregationInput | RedesSocialesOrderByWithAggregationInput[]
    by: RedesSocialesScalarFieldEnum[] | RedesSocialesScalarFieldEnum
    having?: RedesSocialesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedesSocialesCountAggregateInputType | true
    _avg?: RedesSocialesAvgAggregateInputType
    _sum?: RedesSocialesSumAggregateInputType
    _min?: RedesSocialesMinAggregateInputType
    _max?: RedesSocialesMaxAggregateInputType
  }

  export type RedesSocialesGroupByOutputType = {
    id: number
    instagram: string | null
    facebook: string | null
    tiktok: string | null
    whatsapp: string | null
    website: string | null
    emprendimientoId: number
    _count: RedesSocialesCountAggregateOutputType | null
    _avg: RedesSocialesAvgAggregateOutputType | null
    _sum: RedesSocialesSumAggregateOutputType | null
    _min: RedesSocialesMinAggregateOutputType | null
    _max: RedesSocialesMaxAggregateOutputType | null
  }

  type GetRedesSocialesGroupByPayload<T extends RedesSocialesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedesSocialesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedesSocialesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedesSocialesGroupByOutputType[P]>
            : GetScalarType<T[P], RedesSocialesGroupByOutputType[P]>
        }
      >
    >


  export type RedesSocialesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instagram?: boolean
    facebook?: boolean
    tiktok?: boolean
    whatsapp?: boolean
    website?: boolean
    emprendimientoId?: boolean
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redesSociales"]>


  export type RedesSocialesSelectScalar = {
    id?: boolean
    instagram?: boolean
    facebook?: boolean
    tiktok?: boolean
    whatsapp?: boolean
    website?: boolean
    emprendimientoId?: boolean
  }

  export type RedesSocialesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }

  export type $RedesSocialesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RedesSociales"
    objects: {
      emprendimiento: Prisma.$EmprendimientoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      instagram: string | null
      facebook: string | null
      tiktok: string | null
      whatsapp: string | null
      website: string | null
      emprendimientoId: number
    }, ExtArgs["result"]["redesSociales"]>
    composites: {}
  }

  type RedesSocialesGetPayload<S extends boolean | null | undefined | RedesSocialesDefaultArgs> = $Result.GetResult<Prisma.$RedesSocialesPayload, S>

  type RedesSocialesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RedesSocialesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RedesSocialesCountAggregateInputType | true
    }

  export interface RedesSocialesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RedesSociales'], meta: { name: 'RedesSociales' } }
    /**
     * Find zero or one RedesSociales that matches the filter.
     * @param {RedesSocialesFindUniqueArgs} args - Arguments to find a RedesSociales
     * @example
     * // Get one RedesSociales
     * const redesSociales = await prisma.redesSociales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedesSocialesFindUniqueArgs>(args: SelectSubset<T, RedesSocialesFindUniqueArgs<ExtArgs>>): Prisma__RedesSocialesClient<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RedesSociales that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RedesSocialesFindUniqueOrThrowArgs} args - Arguments to find a RedesSociales
     * @example
     * // Get one RedesSociales
     * const redesSociales = await prisma.redesSociales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedesSocialesFindUniqueOrThrowArgs>(args: SelectSubset<T, RedesSocialesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedesSocialesClient<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RedesSociales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedesSocialesFindFirstArgs} args - Arguments to find a RedesSociales
     * @example
     * // Get one RedesSociales
     * const redesSociales = await prisma.redesSociales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedesSocialesFindFirstArgs>(args?: SelectSubset<T, RedesSocialesFindFirstArgs<ExtArgs>>): Prisma__RedesSocialesClient<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RedesSociales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedesSocialesFindFirstOrThrowArgs} args - Arguments to find a RedesSociales
     * @example
     * // Get one RedesSociales
     * const redesSociales = await prisma.redesSociales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedesSocialesFindFirstOrThrowArgs>(args?: SelectSubset<T, RedesSocialesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedesSocialesClient<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RedesSociales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedesSocialesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RedesSociales
     * const redesSociales = await prisma.redesSociales.findMany()
     * 
     * // Get first 10 RedesSociales
     * const redesSociales = await prisma.redesSociales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redesSocialesWithIdOnly = await prisma.redesSociales.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedesSocialesFindManyArgs>(args?: SelectSubset<T, RedesSocialesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RedesSociales.
     * @param {RedesSocialesCreateArgs} args - Arguments to create a RedesSociales.
     * @example
     * // Create one RedesSociales
     * const RedesSociales = await prisma.redesSociales.create({
     *   data: {
     *     // ... data to create a RedesSociales
     *   }
     * })
     * 
     */
    create<T extends RedesSocialesCreateArgs>(args: SelectSubset<T, RedesSocialesCreateArgs<ExtArgs>>): Prisma__RedesSocialesClient<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RedesSociales.
     * @param {RedesSocialesCreateManyArgs} args - Arguments to create many RedesSociales.
     * @example
     * // Create many RedesSociales
     * const redesSociales = await prisma.redesSociales.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedesSocialesCreateManyArgs>(args?: SelectSubset<T, RedesSocialesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RedesSociales.
     * @param {RedesSocialesDeleteArgs} args - Arguments to delete one RedesSociales.
     * @example
     * // Delete one RedesSociales
     * const RedesSociales = await prisma.redesSociales.delete({
     *   where: {
     *     // ... filter to delete one RedesSociales
     *   }
     * })
     * 
     */
    delete<T extends RedesSocialesDeleteArgs>(args: SelectSubset<T, RedesSocialesDeleteArgs<ExtArgs>>): Prisma__RedesSocialesClient<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RedesSociales.
     * @param {RedesSocialesUpdateArgs} args - Arguments to update one RedesSociales.
     * @example
     * // Update one RedesSociales
     * const redesSociales = await prisma.redesSociales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedesSocialesUpdateArgs>(args: SelectSubset<T, RedesSocialesUpdateArgs<ExtArgs>>): Prisma__RedesSocialesClient<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RedesSociales.
     * @param {RedesSocialesDeleteManyArgs} args - Arguments to filter RedesSociales to delete.
     * @example
     * // Delete a few RedesSociales
     * const { count } = await prisma.redesSociales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedesSocialesDeleteManyArgs>(args?: SelectSubset<T, RedesSocialesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RedesSociales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedesSocialesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RedesSociales
     * const redesSociales = await prisma.redesSociales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedesSocialesUpdateManyArgs>(args: SelectSubset<T, RedesSocialesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RedesSociales.
     * @param {RedesSocialesUpsertArgs} args - Arguments to update or create a RedesSociales.
     * @example
     * // Update or create a RedesSociales
     * const redesSociales = await prisma.redesSociales.upsert({
     *   create: {
     *     // ... data to create a RedesSociales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RedesSociales we want to update
     *   }
     * })
     */
    upsert<T extends RedesSocialesUpsertArgs>(args: SelectSubset<T, RedesSocialesUpsertArgs<ExtArgs>>): Prisma__RedesSocialesClient<$Result.GetResult<Prisma.$RedesSocialesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RedesSociales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedesSocialesCountArgs} args - Arguments to filter RedesSociales to count.
     * @example
     * // Count the number of RedesSociales
     * const count = await prisma.redesSociales.count({
     *   where: {
     *     // ... the filter for the RedesSociales we want to count
     *   }
     * })
    **/
    count<T extends RedesSocialesCountArgs>(
      args?: Subset<T, RedesSocialesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedesSocialesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RedesSociales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedesSocialesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedesSocialesAggregateArgs>(args: Subset<T, RedesSocialesAggregateArgs>): Prisma.PrismaPromise<GetRedesSocialesAggregateType<T>>

    /**
     * Group by RedesSociales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedesSocialesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedesSocialesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedesSocialesGroupByArgs['orderBy'] }
        : { orderBy?: RedesSocialesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedesSocialesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedesSocialesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RedesSociales model
   */
  readonly fields: RedesSocialesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RedesSociales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedesSocialesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emprendimiento<T extends EmprendimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmprendimientoDefaultArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RedesSociales model
   */ 
  interface RedesSocialesFieldRefs {
    readonly id: FieldRef<"RedesSociales", 'Int'>
    readonly instagram: FieldRef<"RedesSociales", 'String'>
    readonly facebook: FieldRef<"RedesSociales", 'String'>
    readonly tiktok: FieldRef<"RedesSociales", 'String'>
    readonly whatsapp: FieldRef<"RedesSociales", 'String'>
    readonly website: FieldRef<"RedesSociales", 'String'>
    readonly emprendimientoId: FieldRef<"RedesSociales", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RedesSociales findUnique
   */
  export type RedesSocialesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    /**
     * Filter, which RedesSociales to fetch.
     */
    where: RedesSocialesWhereUniqueInput
  }

  /**
   * RedesSociales findUniqueOrThrow
   */
  export type RedesSocialesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    /**
     * Filter, which RedesSociales to fetch.
     */
    where: RedesSocialesWhereUniqueInput
  }

  /**
   * RedesSociales findFirst
   */
  export type RedesSocialesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    /**
     * Filter, which RedesSociales to fetch.
     */
    where?: RedesSocialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedesSociales to fetch.
     */
    orderBy?: RedesSocialesOrderByWithRelationInput | RedesSocialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedesSociales.
     */
    cursor?: RedesSocialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedesSociales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedesSociales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedesSociales.
     */
    distinct?: RedesSocialesScalarFieldEnum | RedesSocialesScalarFieldEnum[]
  }

  /**
   * RedesSociales findFirstOrThrow
   */
  export type RedesSocialesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    /**
     * Filter, which RedesSociales to fetch.
     */
    where?: RedesSocialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedesSociales to fetch.
     */
    orderBy?: RedesSocialesOrderByWithRelationInput | RedesSocialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RedesSociales.
     */
    cursor?: RedesSocialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedesSociales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedesSociales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RedesSociales.
     */
    distinct?: RedesSocialesScalarFieldEnum | RedesSocialesScalarFieldEnum[]
  }

  /**
   * RedesSociales findMany
   */
  export type RedesSocialesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    /**
     * Filter, which RedesSociales to fetch.
     */
    where?: RedesSocialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RedesSociales to fetch.
     */
    orderBy?: RedesSocialesOrderByWithRelationInput | RedesSocialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RedesSociales.
     */
    cursor?: RedesSocialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RedesSociales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RedesSociales.
     */
    skip?: number
    distinct?: RedesSocialesScalarFieldEnum | RedesSocialesScalarFieldEnum[]
  }

  /**
   * RedesSociales create
   */
  export type RedesSocialesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    /**
     * The data needed to create a RedesSociales.
     */
    data: XOR<RedesSocialesCreateInput, RedesSocialesUncheckedCreateInput>
  }

  /**
   * RedesSociales createMany
   */
  export type RedesSocialesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RedesSociales.
     */
    data: RedesSocialesCreateManyInput | RedesSocialesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RedesSociales update
   */
  export type RedesSocialesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    /**
     * The data needed to update a RedesSociales.
     */
    data: XOR<RedesSocialesUpdateInput, RedesSocialesUncheckedUpdateInput>
    /**
     * Choose, which RedesSociales to update.
     */
    where: RedesSocialesWhereUniqueInput
  }

  /**
   * RedesSociales updateMany
   */
  export type RedesSocialesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RedesSociales.
     */
    data: XOR<RedesSocialesUpdateManyMutationInput, RedesSocialesUncheckedUpdateManyInput>
    /**
     * Filter which RedesSociales to update
     */
    where?: RedesSocialesWhereInput
  }

  /**
   * RedesSociales upsert
   */
  export type RedesSocialesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    /**
     * The filter to search for the RedesSociales to update in case it exists.
     */
    where: RedesSocialesWhereUniqueInput
    /**
     * In case the RedesSociales found by the `where` argument doesn't exist, create a new RedesSociales with this data.
     */
    create: XOR<RedesSocialesCreateInput, RedesSocialesUncheckedCreateInput>
    /**
     * In case the RedesSociales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedesSocialesUpdateInput, RedesSocialesUncheckedUpdateInput>
  }

  /**
   * RedesSociales delete
   */
  export type RedesSocialesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
    /**
     * Filter which RedesSociales to delete.
     */
    where: RedesSocialesWhereUniqueInput
  }

  /**
   * RedesSociales deleteMany
   */
  export type RedesSocialesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RedesSociales to delete
     */
    where?: RedesSocialesWhereInput
  }

  /**
   * RedesSociales without action
   */
  export type RedesSocialesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedesSociales
     */
    select?: RedesSocialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedesSocialesInclude<ExtArgs> | null
  }


  /**
   * Model Mentoria
   */

  export type AggregateMentoria = {
    _count: MentoriaCountAggregateOutputType | null
    _avg: MentoriaAvgAggregateOutputType | null
    _sum: MentoriaSumAggregateOutputType | null
    _min: MentoriaMinAggregateOutputType | null
    _max: MentoriaMaxAggregateOutputType | null
  }

  export type MentoriaAvgAggregateOutputType = {
    id: number | null
    tutorId: number | null
    emprendimientoId: number | null
  }

  export type MentoriaSumAggregateOutputType = {
    id: number | null
    tutorId: number | null
    emprendimientoId: number | null
  }

  export type MentoriaMinAggregateOutputType = {
    id: number | null
    tema: string | null
    fechaProgramada: Date | null
    estado: $Enums.EstadoMentoria | null
    notas: string | null
    tutorId: number | null
    emprendimientoId: number | null
  }

  export type MentoriaMaxAggregateOutputType = {
    id: number | null
    tema: string | null
    fechaProgramada: Date | null
    estado: $Enums.EstadoMentoria | null
    notas: string | null
    tutorId: number | null
    emprendimientoId: number | null
  }

  export type MentoriaCountAggregateOutputType = {
    id: number
    tema: number
    fechaProgramada: number
    estado: number
    notas: number
    tutorId: number
    emprendimientoId: number
    _all: number
  }


  export type MentoriaAvgAggregateInputType = {
    id?: true
    tutorId?: true
    emprendimientoId?: true
  }

  export type MentoriaSumAggregateInputType = {
    id?: true
    tutorId?: true
    emprendimientoId?: true
  }

  export type MentoriaMinAggregateInputType = {
    id?: true
    tema?: true
    fechaProgramada?: true
    estado?: true
    notas?: true
    tutorId?: true
    emprendimientoId?: true
  }

  export type MentoriaMaxAggregateInputType = {
    id?: true
    tema?: true
    fechaProgramada?: true
    estado?: true
    notas?: true
    tutorId?: true
    emprendimientoId?: true
  }

  export type MentoriaCountAggregateInputType = {
    id?: true
    tema?: true
    fechaProgramada?: true
    estado?: true
    notas?: true
    tutorId?: true
    emprendimientoId?: true
    _all?: true
  }

  export type MentoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentoria to aggregate.
     */
    where?: MentoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorias to fetch.
     */
    orderBy?: MentoriaOrderByWithRelationInput | MentoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mentorias
    **/
    _count?: true | MentoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentoriaMaxAggregateInputType
  }

  export type GetMentoriaAggregateType<T extends MentoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateMentoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentoria[P]>
      : GetScalarType<T[P], AggregateMentoria[P]>
  }




  export type MentoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentoriaWhereInput
    orderBy?: MentoriaOrderByWithAggregationInput | MentoriaOrderByWithAggregationInput[]
    by: MentoriaScalarFieldEnum[] | MentoriaScalarFieldEnum
    having?: MentoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentoriaCountAggregateInputType | true
    _avg?: MentoriaAvgAggregateInputType
    _sum?: MentoriaSumAggregateInputType
    _min?: MentoriaMinAggregateInputType
    _max?: MentoriaMaxAggregateInputType
  }

  export type MentoriaGroupByOutputType = {
    id: number
    tema: string
    fechaProgramada: Date
    estado: $Enums.EstadoMentoria
    notas: string | null
    tutorId: number
    emprendimientoId: number
    _count: MentoriaCountAggregateOutputType | null
    _avg: MentoriaAvgAggregateOutputType | null
    _sum: MentoriaSumAggregateOutputType | null
    _min: MentoriaMinAggregateOutputType | null
    _max: MentoriaMaxAggregateOutputType | null
  }

  type GetMentoriaGroupByPayload<T extends MentoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentoriaGroupByOutputType[P]>
            : GetScalarType<T[P], MentoriaGroupByOutputType[P]>
        }
      >
    >


  export type MentoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tema?: boolean
    fechaProgramada?: boolean
    estado?: boolean
    notas?: boolean
    tutorId?: boolean
    emprendimientoId?: boolean
    tutor?: boolean | UsuarioDefaultArgs<ExtArgs>
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentoria"]>


  export type MentoriaSelectScalar = {
    id?: boolean
    tema?: boolean
    fechaProgramada?: boolean
    estado?: boolean
    notas?: boolean
    tutorId?: boolean
    emprendimientoId?: boolean
  }

  export type MentoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | UsuarioDefaultArgs<ExtArgs>
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }

  export type $MentoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mentoria"
    objects: {
      tutor: Prisma.$UsuarioPayload<ExtArgs>
      emprendimiento: Prisma.$EmprendimientoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tema: string
      fechaProgramada: Date
      estado: $Enums.EstadoMentoria
      notas: string | null
      tutorId: number
      emprendimientoId: number
    }, ExtArgs["result"]["mentoria"]>
    composites: {}
  }

  type MentoriaGetPayload<S extends boolean | null | undefined | MentoriaDefaultArgs> = $Result.GetResult<Prisma.$MentoriaPayload, S>

  type MentoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MentoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentoriaCountAggregateInputType | true
    }

  export interface MentoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mentoria'], meta: { name: 'Mentoria' } }
    /**
     * Find zero or one Mentoria that matches the filter.
     * @param {MentoriaFindUniqueArgs} args - Arguments to find a Mentoria
     * @example
     * // Get one Mentoria
     * const mentoria = await prisma.mentoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentoriaFindUniqueArgs>(args: SelectSubset<T, MentoriaFindUniqueArgs<ExtArgs>>): Prisma__MentoriaClient<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mentoria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MentoriaFindUniqueOrThrowArgs} args - Arguments to find a Mentoria
     * @example
     * // Get one Mentoria
     * const mentoria = await prisma.mentoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, MentoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentoriaClient<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mentoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentoriaFindFirstArgs} args - Arguments to find a Mentoria
     * @example
     * // Get one Mentoria
     * const mentoria = await prisma.mentoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentoriaFindFirstArgs>(args?: SelectSubset<T, MentoriaFindFirstArgs<ExtArgs>>): Prisma__MentoriaClient<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mentoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentoriaFindFirstOrThrowArgs} args - Arguments to find a Mentoria
     * @example
     * // Get one Mentoria
     * const mentoria = await prisma.mentoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, MentoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentoriaClient<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mentorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentorias
     * const mentorias = await prisma.mentoria.findMany()
     * 
     * // Get first 10 Mentorias
     * const mentorias = await prisma.mentoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentoriaWithIdOnly = await prisma.mentoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentoriaFindManyArgs>(args?: SelectSubset<T, MentoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mentoria.
     * @param {MentoriaCreateArgs} args - Arguments to create a Mentoria.
     * @example
     * // Create one Mentoria
     * const Mentoria = await prisma.mentoria.create({
     *   data: {
     *     // ... data to create a Mentoria
     *   }
     * })
     * 
     */
    create<T extends MentoriaCreateArgs>(args: SelectSubset<T, MentoriaCreateArgs<ExtArgs>>): Prisma__MentoriaClient<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mentorias.
     * @param {MentoriaCreateManyArgs} args - Arguments to create many Mentorias.
     * @example
     * // Create many Mentorias
     * const mentoria = await prisma.mentoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentoriaCreateManyArgs>(args?: SelectSubset<T, MentoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mentoria.
     * @param {MentoriaDeleteArgs} args - Arguments to delete one Mentoria.
     * @example
     * // Delete one Mentoria
     * const Mentoria = await prisma.mentoria.delete({
     *   where: {
     *     // ... filter to delete one Mentoria
     *   }
     * })
     * 
     */
    delete<T extends MentoriaDeleteArgs>(args: SelectSubset<T, MentoriaDeleteArgs<ExtArgs>>): Prisma__MentoriaClient<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mentoria.
     * @param {MentoriaUpdateArgs} args - Arguments to update one Mentoria.
     * @example
     * // Update one Mentoria
     * const mentoria = await prisma.mentoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentoriaUpdateArgs>(args: SelectSubset<T, MentoriaUpdateArgs<ExtArgs>>): Prisma__MentoriaClient<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mentorias.
     * @param {MentoriaDeleteManyArgs} args - Arguments to filter Mentorias to delete.
     * @example
     * // Delete a few Mentorias
     * const { count } = await prisma.mentoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentoriaDeleteManyArgs>(args?: SelectSubset<T, MentoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentorias
     * const mentoria = await prisma.mentoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentoriaUpdateManyArgs>(args: SelectSubset<T, MentoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mentoria.
     * @param {MentoriaUpsertArgs} args - Arguments to update or create a Mentoria.
     * @example
     * // Update or create a Mentoria
     * const mentoria = await prisma.mentoria.upsert({
     *   create: {
     *     // ... data to create a Mentoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mentoria we want to update
     *   }
     * })
     */
    upsert<T extends MentoriaUpsertArgs>(args: SelectSubset<T, MentoriaUpsertArgs<ExtArgs>>): Prisma__MentoriaClient<$Result.GetResult<Prisma.$MentoriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mentorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentoriaCountArgs} args - Arguments to filter Mentorias to count.
     * @example
     * // Count the number of Mentorias
     * const count = await prisma.mentoria.count({
     *   where: {
     *     // ... the filter for the Mentorias we want to count
     *   }
     * })
    **/
    count<T extends MentoriaCountArgs>(
      args?: Subset<T, MentoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mentoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentoriaAggregateArgs>(args: Subset<T, MentoriaAggregateArgs>): Prisma.PrismaPromise<GetMentoriaAggregateType<T>>

    /**
     * Group by Mentoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentoriaGroupByArgs['orderBy'] }
        : { orderBy?: MentoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mentoria model
   */
  readonly fields: MentoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mentoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tutor<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    emprendimiento<T extends EmprendimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmprendimientoDefaultArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mentoria model
   */ 
  interface MentoriaFieldRefs {
    readonly id: FieldRef<"Mentoria", 'Int'>
    readonly tema: FieldRef<"Mentoria", 'String'>
    readonly fechaProgramada: FieldRef<"Mentoria", 'DateTime'>
    readonly estado: FieldRef<"Mentoria", 'EstadoMentoria'>
    readonly notas: FieldRef<"Mentoria", 'String'>
    readonly tutorId: FieldRef<"Mentoria", 'Int'>
    readonly emprendimientoId: FieldRef<"Mentoria", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Mentoria findUnique
   */
  export type MentoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    /**
     * Filter, which Mentoria to fetch.
     */
    where: MentoriaWhereUniqueInput
  }

  /**
   * Mentoria findUniqueOrThrow
   */
  export type MentoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    /**
     * Filter, which Mentoria to fetch.
     */
    where: MentoriaWhereUniqueInput
  }

  /**
   * Mentoria findFirst
   */
  export type MentoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    /**
     * Filter, which Mentoria to fetch.
     */
    where?: MentoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorias to fetch.
     */
    orderBy?: MentoriaOrderByWithRelationInput | MentoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentorias.
     */
    cursor?: MentoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentorias.
     */
    distinct?: MentoriaScalarFieldEnum | MentoriaScalarFieldEnum[]
  }

  /**
   * Mentoria findFirstOrThrow
   */
  export type MentoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    /**
     * Filter, which Mentoria to fetch.
     */
    where?: MentoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorias to fetch.
     */
    orderBy?: MentoriaOrderByWithRelationInput | MentoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mentorias.
     */
    cursor?: MentoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mentorias.
     */
    distinct?: MentoriaScalarFieldEnum | MentoriaScalarFieldEnum[]
  }

  /**
   * Mentoria findMany
   */
  export type MentoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    /**
     * Filter, which Mentorias to fetch.
     */
    where?: MentoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mentorias to fetch.
     */
    orderBy?: MentoriaOrderByWithRelationInput | MentoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mentorias.
     */
    cursor?: MentoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mentorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mentorias.
     */
    skip?: number
    distinct?: MentoriaScalarFieldEnum | MentoriaScalarFieldEnum[]
  }

  /**
   * Mentoria create
   */
  export type MentoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Mentoria.
     */
    data: XOR<MentoriaCreateInput, MentoriaUncheckedCreateInput>
  }

  /**
   * Mentoria createMany
   */
  export type MentoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mentorias.
     */
    data: MentoriaCreateManyInput | MentoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mentoria update
   */
  export type MentoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Mentoria.
     */
    data: XOR<MentoriaUpdateInput, MentoriaUncheckedUpdateInput>
    /**
     * Choose, which Mentoria to update.
     */
    where: MentoriaWhereUniqueInput
  }

  /**
   * Mentoria updateMany
   */
  export type MentoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mentorias.
     */
    data: XOR<MentoriaUpdateManyMutationInput, MentoriaUncheckedUpdateManyInput>
    /**
     * Filter which Mentorias to update
     */
    where?: MentoriaWhereInput
  }

  /**
   * Mentoria upsert
   */
  export type MentoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Mentoria to update in case it exists.
     */
    where: MentoriaWhereUniqueInput
    /**
     * In case the Mentoria found by the `where` argument doesn't exist, create a new Mentoria with this data.
     */
    create: XOR<MentoriaCreateInput, MentoriaUncheckedCreateInput>
    /**
     * In case the Mentoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentoriaUpdateInput, MentoriaUncheckedUpdateInput>
  }

  /**
   * Mentoria delete
   */
  export type MentoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
    /**
     * Filter which Mentoria to delete.
     */
    where: MentoriaWhereUniqueInput
  }

  /**
   * Mentoria deleteMany
   */
  export type MentoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mentorias to delete
     */
    where?: MentoriaWhereInput
  }

  /**
   * Mentoria without action
   */
  export type MentoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mentoria
     */
    select?: MentoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentoriaInclude<ExtArgs> | null
  }


  /**
   * Model Resena
   */

  export type AggregateResena = {
    _count: ResenaCountAggregateOutputType | null
    _avg: ResenaAvgAggregateOutputType | null
    _sum: ResenaSumAggregateOutputType | null
    _min: ResenaMinAggregateOutputType | null
    _max: ResenaMaxAggregateOutputType | null
  }

  export type ResenaAvgAggregateOutputType = {
    id: number | null
    calificacion: number | null
    usuarioId: number | null
    emprendimientoId: number | null
  }

  export type ResenaSumAggregateOutputType = {
    id: number | null
    calificacion: number | null
    usuarioId: number | null
    emprendimientoId: number | null
  }

  export type ResenaMinAggregateOutputType = {
    id: number | null
    calificacion: number | null
    comentario: string | null
    fecha: Date | null
    usuarioId: number | null
    emprendimientoId: number | null
  }

  export type ResenaMaxAggregateOutputType = {
    id: number | null
    calificacion: number | null
    comentario: string | null
    fecha: Date | null
    usuarioId: number | null
    emprendimientoId: number | null
  }

  export type ResenaCountAggregateOutputType = {
    id: number
    calificacion: number
    comentario: number
    fecha: number
    usuarioId: number
    emprendimientoId: number
    _all: number
  }


  export type ResenaAvgAggregateInputType = {
    id?: true
    calificacion?: true
    usuarioId?: true
    emprendimientoId?: true
  }

  export type ResenaSumAggregateInputType = {
    id?: true
    calificacion?: true
    usuarioId?: true
    emprendimientoId?: true
  }

  export type ResenaMinAggregateInputType = {
    id?: true
    calificacion?: true
    comentario?: true
    fecha?: true
    usuarioId?: true
    emprendimientoId?: true
  }

  export type ResenaMaxAggregateInputType = {
    id?: true
    calificacion?: true
    comentario?: true
    fecha?: true
    usuarioId?: true
    emprendimientoId?: true
  }

  export type ResenaCountAggregateInputType = {
    id?: true
    calificacion?: true
    comentario?: true
    fecha?: true
    usuarioId?: true
    emprendimientoId?: true
    _all?: true
  }

  export type ResenaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resena to aggregate.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resenas
    **/
    _count?: true | ResenaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResenaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResenaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResenaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResenaMaxAggregateInputType
  }

  export type GetResenaAggregateType<T extends ResenaAggregateArgs> = {
        [P in keyof T & keyof AggregateResena]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResena[P]>
      : GetScalarType<T[P], AggregateResena[P]>
  }




  export type ResenaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResenaWhereInput
    orderBy?: ResenaOrderByWithAggregationInput | ResenaOrderByWithAggregationInput[]
    by: ResenaScalarFieldEnum[] | ResenaScalarFieldEnum
    having?: ResenaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResenaCountAggregateInputType | true
    _avg?: ResenaAvgAggregateInputType
    _sum?: ResenaSumAggregateInputType
    _min?: ResenaMinAggregateInputType
    _max?: ResenaMaxAggregateInputType
  }

  export type ResenaGroupByOutputType = {
    id: number
    calificacion: number
    comentario: string | null
    fecha: Date
    usuarioId: number
    emprendimientoId: number
    _count: ResenaCountAggregateOutputType | null
    _avg: ResenaAvgAggregateOutputType | null
    _sum: ResenaSumAggregateOutputType | null
    _min: ResenaMinAggregateOutputType | null
    _max: ResenaMaxAggregateOutputType | null
  }

  type GetResenaGroupByPayload<T extends ResenaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResenaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResenaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResenaGroupByOutputType[P]>
            : GetScalarType<T[P], ResenaGroupByOutputType[P]>
        }
      >
    >


  export type ResenaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calificacion?: boolean
    comentario?: boolean
    fecha?: boolean
    usuarioId?: boolean
    emprendimientoId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resena"]>


  export type ResenaSelectScalar = {
    id?: boolean
    calificacion?: boolean
    comentario?: boolean
    fecha?: boolean
    usuarioId?: boolean
    emprendimientoId?: boolean
  }

  export type ResenaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }

  export type $ResenaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resena"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      emprendimiento: Prisma.$EmprendimientoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      calificacion: number
      comentario: string | null
      fecha: Date
      usuarioId: number
      emprendimientoId: number
    }, ExtArgs["result"]["resena"]>
    composites: {}
  }

  type ResenaGetPayload<S extends boolean | null | undefined | ResenaDefaultArgs> = $Result.GetResult<Prisma.$ResenaPayload, S>

  type ResenaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResenaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResenaCountAggregateInputType | true
    }

  export interface ResenaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resena'], meta: { name: 'Resena' } }
    /**
     * Find zero or one Resena that matches the filter.
     * @param {ResenaFindUniqueArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResenaFindUniqueArgs>(args: SelectSubset<T, ResenaFindUniqueArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Resena that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResenaFindUniqueOrThrowArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResenaFindUniqueOrThrowArgs>(args: SelectSubset<T, ResenaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Resena that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindFirstArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResenaFindFirstArgs>(args?: SelectSubset<T, ResenaFindFirstArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Resena that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindFirstOrThrowArgs} args - Arguments to find a Resena
     * @example
     * // Get one Resena
     * const resena = await prisma.resena.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResenaFindFirstOrThrowArgs>(args?: SelectSubset<T, ResenaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Resenas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resenas
     * const resenas = await prisma.resena.findMany()
     * 
     * // Get first 10 Resenas
     * const resenas = await prisma.resena.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resenaWithIdOnly = await prisma.resena.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResenaFindManyArgs>(args?: SelectSubset<T, ResenaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Resena.
     * @param {ResenaCreateArgs} args - Arguments to create a Resena.
     * @example
     * // Create one Resena
     * const Resena = await prisma.resena.create({
     *   data: {
     *     // ... data to create a Resena
     *   }
     * })
     * 
     */
    create<T extends ResenaCreateArgs>(args: SelectSubset<T, ResenaCreateArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Resenas.
     * @param {ResenaCreateManyArgs} args - Arguments to create many Resenas.
     * @example
     * // Create many Resenas
     * const resena = await prisma.resena.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResenaCreateManyArgs>(args?: SelectSubset<T, ResenaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resena.
     * @param {ResenaDeleteArgs} args - Arguments to delete one Resena.
     * @example
     * // Delete one Resena
     * const Resena = await prisma.resena.delete({
     *   where: {
     *     // ... filter to delete one Resena
     *   }
     * })
     * 
     */
    delete<T extends ResenaDeleteArgs>(args: SelectSubset<T, ResenaDeleteArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Resena.
     * @param {ResenaUpdateArgs} args - Arguments to update one Resena.
     * @example
     * // Update one Resena
     * const resena = await prisma.resena.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResenaUpdateArgs>(args: SelectSubset<T, ResenaUpdateArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Resenas.
     * @param {ResenaDeleteManyArgs} args - Arguments to filter Resenas to delete.
     * @example
     * // Delete a few Resenas
     * const { count } = await prisma.resena.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResenaDeleteManyArgs>(args?: SelectSubset<T, ResenaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resenas
     * const resena = await prisma.resena.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResenaUpdateManyArgs>(args: SelectSubset<T, ResenaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resena.
     * @param {ResenaUpsertArgs} args - Arguments to update or create a Resena.
     * @example
     * // Update or create a Resena
     * const resena = await prisma.resena.upsert({
     *   create: {
     *     // ... data to create a Resena
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resena we want to update
     *   }
     * })
     */
    upsert<T extends ResenaUpsertArgs>(args: SelectSubset<T, ResenaUpsertArgs<ExtArgs>>): Prisma__ResenaClient<$Result.GetResult<Prisma.$ResenaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Resenas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaCountArgs} args - Arguments to filter Resenas to count.
     * @example
     * // Count the number of Resenas
     * const count = await prisma.resena.count({
     *   where: {
     *     // ... the filter for the Resenas we want to count
     *   }
     * })
    **/
    count<T extends ResenaCountArgs>(
      args?: Subset<T, ResenaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResenaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResenaAggregateArgs>(args: Subset<T, ResenaAggregateArgs>): Prisma.PrismaPromise<GetResenaAggregateType<T>>

    /**
     * Group by Resena.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResenaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResenaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResenaGroupByArgs['orderBy'] }
        : { orderBy?: ResenaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResenaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResenaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resena model
   */
  readonly fields: ResenaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resena.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResenaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    emprendimiento<T extends EmprendimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmprendimientoDefaultArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resena model
   */ 
  interface ResenaFieldRefs {
    readonly id: FieldRef<"Resena", 'Int'>
    readonly calificacion: FieldRef<"Resena", 'Int'>
    readonly comentario: FieldRef<"Resena", 'String'>
    readonly fecha: FieldRef<"Resena", 'DateTime'>
    readonly usuarioId: FieldRef<"Resena", 'Int'>
    readonly emprendimientoId: FieldRef<"Resena", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Resena findUnique
   */
  export type ResenaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena findUniqueOrThrow
   */
  export type ResenaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena findFirst
   */
  export type ResenaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resenas.
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resenas.
     */
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Resena findFirstOrThrow
   */
  export type ResenaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resena to fetch.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resenas.
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resenas.
     */
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Resena findMany
   */
  export type ResenaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter, which Resenas to fetch.
     */
    where?: ResenaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resenas to fetch.
     */
    orderBy?: ResenaOrderByWithRelationInput | ResenaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resenas.
     */
    cursor?: ResenaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resenas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resenas.
     */
    skip?: number
    distinct?: ResenaScalarFieldEnum | ResenaScalarFieldEnum[]
  }

  /**
   * Resena create
   */
  export type ResenaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * The data needed to create a Resena.
     */
    data: XOR<ResenaCreateInput, ResenaUncheckedCreateInput>
  }

  /**
   * Resena createMany
   */
  export type ResenaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resenas.
     */
    data: ResenaCreateManyInput | ResenaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resena update
   */
  export type ResenaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * The data needed to update a Resena.
     */
    data: XOR<ResenaUpdateInput, ResenaUncheckedUpdateInput>
    /**
     * Choose, which Resena to update.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena updateMany
   */
  export type ResenaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resenas.
     */
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyInput>
    /**
     * Filter which Resenas to update
     */
    where?: ResenaWhereInput
  }

  /**
   * Resena upsert
   */
  export type ResenaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * The filter to search for the Resena to update in case it exists.
     */
    where: ResenaWhereUniqueInput
    /**
     * In case the Resena found by the `where` argument doesn't exist, create a new Resena with this data.
     */
    create: XOR<ResenaCreateInput, ResenaUncheckedCreateInput>
    /**
     * In case the Resena was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResenaUpdateInput, ResenaUncheckedUpdateInput>
  }

  /**
   * Resena delete
   */
  export type ResenaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
    /**
     * Filter which Resena to delete.
     */
    where: ResenaWhereUniqueInput
  }

  /**
   * Resena deleteMany
   */
  export type ResenaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resenas to delete
     */
    where?: ResenaWhereInput
  }

  /**
   * Resena without action
   */
  export type ResenaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resena
     */
    select?: ResenaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResenaInclude<ExtArgs> | null
  }


  /**
   * Model Promocion
   */

  export type AggregatePromocion = {
    _count: PromocionCountAggregateOutputType | null
    _avg: PromocionAvgAggregateOutputType | null
    _sum: PromocionSumAggregateOutputType | null
    _min: PromocionMinAggregateOutputType | null
    _max: PromocionMaxAggregateOutputType | null
  }

  export type PromocionAvgAggregateOutputType = {
    id: number | null
    emprendimientoId: number | null
  }

  export type PromocionSumAggregateOutputType = {
    id: number | null
    emprendimientoId: number | null
  }

  export type PromocionMinAggregateOutputType = {
    id: number | null
    titulo: string | null
    descripcion: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    descuento: string | null
    activo: boolean | null
    emprendimientoId: number | null
  }

  export type PromocionMaxAggregateOutputType = {
    id: number | null
    titulo: string | null
    descripcion: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    descuento: string | null
    activo: boolean | null
    emprendimientoId: number | null
  }

  export type PromocionCountAggregateOutputType = {
    id: number
    titulo: number
    descripcion: number
    fechaInicio: number
    fechaFin: number
    descuento: number
    activo: number
    emprendimientoId: number
    _all: number
  }


  export type PromocionAvgAggregateInputType = {
    id?: true
    emprendimientoId?: true
  }

  export type PromocionSumAggregateInputType = {
    id?: true
    emprendimientoId?: true
  }

  export type PromocionMinAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    fechaInicio?: true
    fechaFin?: true
    descuento?: true
    activo?: true
    emprendimientoId?: true
  }

  export type PromocionMaxAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    fechaInicio?: true
    fechaFin?: true
    descuento?: true
    activo?: true
    emprendimientoId?: true
  }

  export type PromocionCountAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    fechaInicio?: true
    fechaFin?: true
    descuento?: true
    activo?: true
    emprendimientoId?: true
    _all?: true
  }

  export type PromocionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promocion to aggregate.
     */
    where?: PromocionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promocions to fetch.
     */
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromocionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promocions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promocions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promocions
    **/
    _count?: true | PromocionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromocionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromocionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromocionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromocionMaxAggregateInputType
  }

  export type GetPromocionAggregateType<T extends PromocionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromocion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromocion[P]>
      : GetScalarType<T[P], AggregatePromocion[P]>
  }




  export type PromocionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromocionWhereInput
    orderBy?: PromocionOrderByWithAggregationInput | PromocionOrderByWithAggregationInput[]
    by: PromocionScalarFieldEnum[] | PromocionScalarFieldEnum
    having?: PromocionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromocionCountAggregateInputType | true
    _avg?: PromocionAvgAggregateInputType
    _sum?: PromocionSumAggregateInputType
    _min?: PromocionMinAggregateInputType
    _max?: PromocionMaxAggregateInputType
  }

  export type PromocionGroupByOutputType = {
    id: number
    titulo: string
    descripcion: string | null
    fechaInicio: Date
    fechaFin: Date
    descuento: string | null
    activo: boolean
    emprendimientoId: number
    _count: PromocionCountAggregateOutputType | null
    _avg: PromocionAvgAggregateOutputType | null
    _sum: PromocionSumAggregateOutputType | null
    _min: PromocionMinAggregateOutputType | null
    _max: PromocionMaxAggregateOutputType | null
  }

  type GetPromocionGroupByPayload<T extends PromocionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromocionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromocionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromocionGroupByOutputType[P]>
            : GetScalarType<T[P], PromocionGroupByOutputType[P]>
        }
      >
    >


  export type PromocionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    descuento?: boolean
    activo?: boolean
    emprendimientoId?: boolean
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promocion"]>


  export type PromocionSelectScalar = {
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    descuento?: boolean
    activo?: boolean
    emprendimientoId?: boolean
  }

  export type PromocionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emprendimiento?: boolean | EmprendimientoDefaultArgs<ExtArgs>
  }

  export type $PromocionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promocion"
    objects: {
      emprendimiento: Prisma.$EmprendimientoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      titulo: string
      descripcion: string | null
      fechaInicio: Date
      fechaFin: Date
      descuento: string | null
      activo: boolean
      emprendimientoId: number
    }, ExtArgs["result"]["promocion"]>
    composites: {}
  }

  type PromocionGetPayload<S extends boolean | null | undefined | PromocionDefaultArgs> = $Result.GetResult<Prisma.$PromocionPayload, S>

  type PromocionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromocionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromocionCountAggregateInputType | true
    }

  export interface PromocionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promocion'], meta: { name: 'Promocion' } }
    /**
     * Find zero or one Promocion that matches the filter.
     * @param {PromocionFindUniqueArgs} args - Arguments to find a Promocion
     * @example
     * // Get one Promocion
     * const promocion = await prisma.promocion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromocionFindUniqueArgs>(args: SelectSubset<T, PromocionFindUniqueArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Promocion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromocionFindUniqueOrThrowArgs} args - Arguments to find a Promocion
     * @example
     * // Get one Promocion
     * const promocion = await prisma.promocion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromocionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromocionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Promocion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionFindFirstArgs} args - Arguments to find a Promocion
     * @example
     * // Get one Promocion
     * const promocion = await prisma.promocion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromocionFindFirstArgs>(args?: SelectSubset<T, PromocionFindFirstArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Promocion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionFindFirstOrThrowArgs} args - Arguments to find a Promocion
     * @example
     * // Get one Promocion
     * const promocion = await prisma.promocion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromocionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromocionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Promocions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promocions
     * const promocions = await prisma.promocion.findMany()
     * 
     * // Get first 10 Promocions
     * const promocions = await prisma.promocion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promocionWithIdOnly = await prisma.promocion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromocionFindManyArgs>(args?: SelectSubset<T, PromocionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Promocion.
     * @param {PromocionCreateArgs} args - Arguments to create a Promocion.
     * @example
     * // Create one Promocion
     * const Promocion = await prisma.promocion.create({
     *   data: {
     *     // ... data to create a Promocion
     *   }
     * })
     * 
     */
    create<T extends PromocionCreateArgs>(args: SelectSubset<T, PromocionCreateArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Promocions.
     * @param {PromocionCreateManyArgs} args - Arguments to create many Promocions.
     * @example
     * // Create many Promocions
     * const promocion = await prisma.promocion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromocionCreateManyArgs>(args?: SelectSubset<T, PromocionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Promocion.
     * @param {PromocionDeleteArgs} args - Arguments to delete one Promocion.
     * @example
     * // Delete one Promocion
     * const Promocion = await prisma.promocion.delete({
     *   where: {
     *     // ... filter to delete one Promocion
     *   }
     * })
     * 
     */
    delete<T extends PromocionDeleteArgs>(args: SelectSubset<T, PromocionDeleteArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Promocion.
     * @param {PromocionUpdateArgs} args - Arguments to update one Promocion.
     * @example
     * // Update one Promocion
     * const promocion = await prisma.promocion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromocionUpdateArgs>(args: SelectSubset<T, PromocionUpdateArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Promocions.
     * @param {PromocionDeleteManyArgs} args - Arguments to filter Promocions to delete.
     * @example
     * // Delete a few Promocions
     * const { count } = await prisma.promocion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromocionDeleteManyArgs>(args?: SelectSubset<T, PromocionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promocions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promocions
     * const promocion = await prisma.promocion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromocionUpdateManyArgs>(args: SelectSubset<T, PromocionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Promocion.
     * @param {PromocionUpsertArgs} args - Arguments to update or create a Promocion.
     * @example
     * // Update or create a Promocion
     * const promocion = await prisma.promocion.upsert({
     *   create: {
     *     // ... data to create a Promocion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promocion we want to update
     *   }
     * })
     */
    upsert<T extends PromocionUpsertArgs>(args: SelectSubset<T, PromocionUpsertArgs<ExtArgs>>): Prisma__PromocionClient<$Result.GetResult<Prisma.$PromocionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Promocions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionCountArgs} args - Arguments to filter Promocions to count.
     * @example
     * // Count the number of Promocions
     * const count = await prisma.promocion.count({
     *   where: {
     *     // ... the filter for the Promocions we want to count
     *   }
     * })
    **/
    count<T extends PromocionCountArgs>(
      args?: Subset<T, PromocionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromocionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promocion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromocionAggregateArgs>(args: Subset<T, PromocionAggregateArgs>): Prisma.PrismaPromise<GetPromocionAggregateType<T>>

    /**
     * Group by Promocion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromocionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromocionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromocionGroupByArgs['orderBy'] }
        : { orderBy?: PromocionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromocionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromocionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promocion model
   */
  readonly fields: PromocionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promocion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromocionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    emprendimiento<T extends EmprendimientoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmprendimientoDefaultArgs<ExtArgs>>): Prisma__EmprendimientoClient<$Result.GetResult<Prisma.$EmprendimientoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promocion model
   */ 
  interface PromocionFieldRefs {
    readonly id: FieldRef<"Promocion", 'Int'>
    readonly titulo: FieldRef<"Promocion", 'String'>
    readonly descripcion: FieldRef<"Promocion", 'String'>
    readonly fechaInicio: FieldRef<"Promocion", 'DateTime'>
    readonly fechaFin: FieldRef<"Promocion", 'DateTime'>
    readonly descuento: FieldRef<"Promocion", 'String'>
    readonly activo: FieldRef<"Promocion", 'Boolean'>
    readonly emprendimientoId: FieldRef<"Promocion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Promocion findUnique
   */
  export type PromocionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocion to fetch.
     */
    where: PromocionWhereUniqueInput
  }

  /**
   * Promocion findUniqueOrThrow
   */
  export type PromocionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocion to fetch.
     */
    where: PromocionWhereUniqueInput
  }

  /**
   * Promocion findFirst
   */
  export type PromocionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocion to fetch.
     */
    where?: PromocionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promocions to fetch.
     */
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promocions.
     */
    cursor?: PromocionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promocions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promocions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promocions.
     */
    distinct?: PromocionScalarFieldEnum | PromocionScalarFieldEnum[]
  }

  /**
   * Promocion findFirstOrThrow
   */
  export type PromocionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocion to fetch.
     */
    where?: PromocionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promocions to fetch.
     */
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promocions.
     */
    cursor?: PromocionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promocions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promocions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promocions.
     */
    distinct?: PromocionScalarFieldEnum | PromocionScalarFieldEnum[]
  }

  /**
   * Promocion findMany
   */
  export type PromocionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter, which Promocions to fetch.
     */
    where?: PromocionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promocions to fetch.
     */
    orderBy?: PromocionOrderByWithRelationInput | PromocionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promocions.
     */
    cursor?: PromocionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promocions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promocions.
     */
    skip?: number
    distinct?: PromocionScalarFieldEnum | PromocionScalarFieldEnum[]
  }

  /**
   * Promocion create
   */
  export type PromocionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promocion.
     */
    data: XOR<PromocionCreateInput, PromocionUncheckedCreateInput>
  }

  /**
   * Promocion createMany
   */
  export type PromocionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promocions.
     */
    data: PromocionCreateManyInput | PromocionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promocion update
   */
  export type PromocionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promocion.
     */
    data: XOR<PromocionUpdateInput, PromocionUncheckedUpdateInput>
    /**
     * Choose, which Promocion to update.
     */
    where: PromocionWhereUniqueInput
  }

  /**
   * Promocion updateMany
   */
  export type PromocionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promocions.
     */
    data: XOR<PromocionUpdateManyMutationInput, PromocionUncheckedUpdateManyInput>
    /**
     * Filter which Promocions to update
     */
    where?: PromocionWhereInput
  }

  /**
   * Promocion upsert
   */
  export type PromocionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promocion to update in case it exists.
     */
    where: PromocionWhereUniqueInput
    /**
     * In case the Promocion found by the `where` argument doesn't exist, create a new Promocion with this data.
     */
    create: XOR<PromocionCreateInput, PromocionUncheckedCreateInput>
    /**
     * In case the Promocion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromocionUpdateInput, PromocionUncheckedUpdateInput>
  }

  /**
   * Promocion delete
   */
  export type PromocionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
    /**
     * Filter which Promocion to delete.
     */
    where: PromocionWhereUniqueInput
  }

  /**
   * Promocion deleteMany
   */
  export type PromocionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promocions to delete
     */
    where?: PromocionWhereInput
  }

  /**
   * Promocion without action
   */
  export type PromocionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promocion
     */
    select?: PromocionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromocionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    email: 'email',
    telefono: 'telefono',
    fechaRegistro: 'fechaRegistro'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const AuthScalarFieldEnum: {
    id: 'id',
    password: 'password',
    usuarioId: 'usuarioId'
  };

  export type AuthScalarFieldEnum = (typeof AuthScalarFieldEnum)[keyof typeof AuthScalarFieldEnum]


  export const RolScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre'
  };

  export type RolScalarFieldEnum = (typeof RolScalarFieldEnum)[keyof typeof RolScalarFieldEnum]


  export const CategoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const EmprendimientoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    logoUrl: 'logoUrl',
    fechaCreacion: 'fechaCreacion',
    estado: 'estado',
    usuarioId: 'usuarioId',
    categoriaId: 'categoriaId'
  };

  export type EmprendimientoScalarFieldEnum = (typeof EmprendimientoScalarFieldEnum)[keyof typeof EmprendimientoScalarFieldEnum]


  export const ProductoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    precio: 'precio',
    imagenUrl: 'imagenUrl',
    activo: 'activo',
    emprendimientoId: 'emprendimientoId'
  };

  export type ProductoScalarFieldEnum = (typeof ProductoScalarFieldEnum)[keyof typeof ProductoScalarFieldEnum]


  export const RedesSocialesScalarFieldEnum: {
    id: 'id',
    instagram: 'instagram',
    facebook: 'facebook',
    tiktok: 'tiktok',
    whatsapp: 'whatsapp',
    website: 'website',
    emprendimientoId: 'emprendimientoId'
  };

  export type RedesSocialesScalarFieldEnum = (typeof RedesSocialesScalarFieldEnum)[keyof typeof RedesSocialesScalarFieldEnum]


  export const MentoriaScalarFieldEnum: {
    id: 'id',
    tema: 'tema',
    fechaProgramada: 'fechaProgramada',
    estado: 'estado',
    notas: 'notas',
    tutorId: 'tutorId',
    emprendimientoId: 'emprendimientoId'
  };

  export type MentoriaScalarFieldEnum = (typeof MentoriaScalarFieldEnum)[keyof typeof MentoriaScalarFieldEnum]


  export const ResenaScalarFieldEnum: {
    id: 'id',
    calificacion: 'calificacion',
    comentario: 'comentario',
    fecha: 'fecha',
    usuarioId: 'usuarioId',
    emprendimientoId: 'emprendimientoId'
  };

  export type ResenaScalarFieldEnum = (typeof ResenaScalarFieldEnum)[keyof typeof ResenaScalarFieldEnum]


  export const PromocionScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    descuento: 'descuento',
    activo: 'activo',
    emprendimientoId: 'emprendimientoId'
  };

  export type PromocionScalarFieldEnum = (typeof PromocionScalarFieldEnum)[keyof typeof PromocionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'EstadoEmprendimiento'
   */
  export type EnumEstadoEmprendimientoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoEmprendimiento'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'EstadoMentoria'
   */
  export type EnumEstadoMentoriaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoMentoria'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    telefono?: StringNullableFilter<"Usuario"> | string | null
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    auth?: XOR<AuthNullableRelationFilter, AuthWhereInput> | null
    roles?: RolListRelationFilter
    emprendimientos?: EmprendimientoListRelationFilter
    mentoriasComoTutor?: MentoriaListRelationFilter
    resenas?: ResenaListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    fechaRegistro?: SortOrder
    auth?: AuthOrderByWithRelationInput
    roles?: RolOrderByRelationAggregateInput
    emprendimientos?: EmprendimientoOrderByRelationAggregateInput
    mentoriasComoTutor?: MentoriaOrderByRelationAggregateInput
    resenas?: ResenaOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringFilter<"Usuario"> | string
    telefono?: StringNullableFilter<"Usuario"> | string | null
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    auth?: XOR<AuthNullableRelationFilter, AuthWhereInput> | null
    roles?: RolListRelationFilter
    emprendimientos?: EmprendimientoListRelationFilter
    mentoriasComoTutor?: MentoriaListRelationFilter
    resenas?: ResenaListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    fechaRegistro?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellido?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    telefono?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    fechaRegistro?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type AuthWhereInput = {
    AND?: AuthWhereInput | AuthWhereInput[]
    OR?: AuthWhereInput[]
    NOT?: AuthWhereInput | AuthWhereInput[]
    id?: IntFilter<"Auth"> | number
    password?: StringFilter<"Auth"> | string
    usuarioId?: IntFilter<"Auth"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type AuthOrderByWithRelationInput = {
    id?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type AuthWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    usuarioId?: number
    AND?: AuthWhereInput | AuthWhereInput[]
    OR?: AuthWhereInput[]
    NOT?: AuthWhereInput | AuthWhereInput[]
    password?: StringFilter<"Auth"> | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "usuarioId">

  export type AuthOrderByWithAggregationInput = {
    id?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
    _count?: AuthCountOrderByAggregateInput
    _avg?: AuthAvgOrderByAggregateInput
    _max?: AuthMaxOrderByAggregateInput
    _min?: AuthMinOrderByAggregateInput
    _sum?: AuthSumOrderByAggregateInput
  }

  export type AuthScalarWhereWithAggregatesInput = {
    AND?: AuthScalarWhereWithAggregatesInput | AuthScalarWhereWithAggregatesInput[]
    OR?: AuthScalarWhereWithAggregatesInput[]
    NOT?: AuthScalarWhereWithAggregatesInput | AuthScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Auth"> | number
    password?: StringWithAggregatesFilter<"Auth"> | string
    usuarioId?: IntWithAggregatesFilter<"Auth"> | number
  }

  export type RolWhereInput = {
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    id?: IntFilter<"Rol"> | number
    nombre?: StringFilter<"Rol"> | string
    usuarios?: UsuarioListRelationFilter
  }

  export type RolOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    usuarios?: UsuarioOrderByRelationAggregateInput
  }

  export type RolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    usuarios?: UsuarioListRelationFilter
  }, "id" | "nombre">

  export type RolOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    _count?: RolCountOrderByAggregateInput
    _avg?: RolAvgOrderByAggregateInput
    _max?: RolMaxOrderByAggregateInput
    _min?: RolMinOrderByAggregateInput
    _sum?: RolSumOrderByAggregateInput
  }

  export type RolScalarWhereWithAggregatesInput = {
    AND?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    OR?: RolScalarWhereWithAggregatesInput[]
    NOT?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rol"> | number
    nombre?: StringWithAggregatesFilter<"Rol"> | string
  }

  export type CategoriaWhereInput = {
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    id?: IntFilter<"Categoria"> | number
    nombre?: StringFilter<"Categoria"> | string
    descripcion?: StringNullableFilter<"Categoria"> | string | null
    emprendimientos?: EmprendimientoListRelationFilter
  }

  export type CategoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    emprendimientos?: EmprendimientoOrderByRelationAggregateInput
  }

  export type CategoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: CategoriaWhereInput | CategoriaWhereInput[]
    OR?: CategoriaWhereInput[]
    NOT?: CategoriaWhereInput | CategoriaWhereInput[]
    descripcion?: StringNullableFilter<"Categoria"> | string | null
    emprendimientos?: EmprendimientoListRelationFilter
  }, "id" | "nombre">

  export type CategoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: CategoriaCountOrderByAggregateInput
    _avg?: CategoriaAvgOrderByAggregateInput
    _max?: CategoriaMaxOrderByAggregateInput
    _min?: CategoriaMinOrderByAggregateInput
    _sum?: CategoriaSumOrderByAggregateInput
  }

  export type CategoriaScalarWhereWithAggregatesInput = {
    AND?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    OR?: CategoriaScalarWhereWithAggregatesInput[]
    NOT?: CategoriaScalarWhereWithAggregatesInput | CategoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Categoria"> | number
    nombre?: StringWithAggregatesFilter<"Categoria"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Categoria"> | string | null
  }

  export type EmprendimientoWhereInput = {
    AND?: EmprendimientoWhereInput | EmprendimientoWhereInput[]
    OR?: EmprendimientoWhereInput[]
    NOT?: EmprendimientoWhereInput | EmprendimientoWhereInput[]
    id?: IntFilter<"Emprendimiento"> | number
    nombre?: StringFilter<"Emprendimiento"> | string
    descripcion?: StringNullableFilter<"Emprendimiento"> | string | null
    logoUrl?: StringNullableFilter<"Emprendimiento"> | string | null
    fechaCreacion?: DateTimeFilter<"Emprendimiento"> | Date | string
    estado?: EnumEstadoEmprendimientoFilter<"Emprendimiento"> | $Enums.EstadoEmprendimiento
    usuarioId?: IntFilter<"Emprendimiento"> | number
    categoriaId?: IntFilter<"Emprendimiento"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    categoria?: XOR<CategoriaRelationFilter, CategoriaWhereInput>
    productos?: ProductoListRelationFilter
    redesSociales?: XOR<RedesSocialesNullableRelationFilter, RedesSocialesWhereInput> | null
    mentorias?: MentoriaListRelationFilter
    resenas?: ResenaListRelationFilter
    promociones?: PromocionListRelationFilter
  }

  export type EmprendimientoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    categoriaId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    categoria?: CategoriaOrderByWithRelationInput
    productos?: ProductoOrderByRelationAggregateInput
    redesSociales?: RedesSocialesOrderByWithRelationInput
    mentorias?: MentoriaOrderByRelationAggregateInput
    resenas?: ResenaOrderByRelationAggregateInput
    promociones?: PromocionOrderByRelationAggregateInput
  }

  export type EmprendimientoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmprendimientoWhereInput | EmprendimientoWhereInput[]
    OR?: EmprendimientoWhereInput[]
    NOT?: EmprendimientoWhereInput | EmprendimientoWhereInput[]
    nombre?: StringFilter<"Emprendimiento"> | string
    descripcion?: StringNullableFilter<"Emprendimiento"> | string | null
    logoUrl?: StringNullableFilter<"Emprendimiento"> | string | null
    fechaCreacion?: DateTimeFilter<"Emprendimiento"> | Date | string
    estado?: EnumEstadoEmprendimientoFilter<"Emprendimiento"> | $Enums.EstadoEmprendimiento
    usuarioId?: IntFilter<"Emprendimiento"> | number
    categoriaId?: IntFilter<"Emprendimiento"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    categoria?: XOR<CategoriaRelationFilter, CategoriaWhereInput>
    productos?: ProductoListRelationFilter
    redesSociales?: XOR<RedesSocialesNullableRelationFilter, RedesSocialesWhereInput> | null
    mentorias?: MentoriaListRelationFilter
    resenas?: ResenaListRelationFilter
    promociones?: PromocionListRelationFilter
  }, "id">

  export type EmprendimientoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    categoriaId?: SortOrder
    _count?: EmprendimientoCountOrderByAggregateInput
    _avg?: EmprendimientoAvgOrderByAggregateInput
    _max?: EmprendimientoMaxOrderByAggregateInput
    _min?: EmprendimientoMinOrderByAggregateInput
    _sum?: EmprendimientoSumOrderByAggregateInput
  }

  export type EmprendimientoScalarWhereWithAggregatesInput = {
    AND?: EmprendimientoScalarWhereWithAggregatesInput | EmprendimientoScalarWhereWithAggregatesInput[]
    OR?: EmprendimientoScalarWhereWithAggregatesInput[]
    NOT?: EmprendimientoScalarWhereWithAggregatesInput | EmprendimientoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Emprendimiento"> | number
    nombre?: StringWithAggregatesFilter<"Emprendimiento"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Emprendimiento"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Emprendimiento"> | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"Emprendimiento"> | Date | string
    estado?: EnumEstadoEmprendimientoWithAggregatesFilter<"Emprendimiento"> | $Enums.EstadoEmprendimiento
    usuarioId?: IntWithAggregatesFilter<"Emprendimiento"> | number
    categoriaId?: IntWithAggregatesFilter<"Emprendimiento"> | number
  }

  export type ProductoWhereInput = {
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    id?: IntFilter<"Producto"> | number
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringNullableFilter<"Producto"> | string | null
    precio?: DecimalFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    imagenUrl?: StringNullableFilter<"Producto"> | string | null
    activo?: BoolFilter<"Producto"> | boolean
    emprendimientoId?: IntFilter<"Producto"> | number
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }

  export type ProductoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    precio?: SortOrder
    imagenUrl?: SortOrderInput | SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
    emprendimiento?: EmprendimientoOrderByWithRelationInput
  }

  export type ProductoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductoWhereInput | ProductoWhereInput[]
    OR?: ProductoWhereInput[]
    NOT?: ProductoWhereInput | ProductoWhereInput[]
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringNullableFilter<"Producto"> | string | null
    precio?: DecimalFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    imagenUrl?: StringNullableFilter<"Producto"> | string | null
    activo?: BoolFilter<"Producto"> | boolean
    emprendimientoId?: IntFilter<"Producto"> | number
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }, "id">

  export type ProductoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    precio?: SortOrder
    imagenUrl?: SortOrderInput | SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
    _count?: ProductoCountOrderByAggregateInput
    _avg?: ProductoAvgOrderByAggregateInput
    _max?: ProductoMaxOrderByAggregateInput
    _min?: ProductoMinOrderByAggregateInput
    _sum?: ProductoSumOrderByAggregateInput
  }

  export type ProductoScalarWhereWithAggregatesInput = {
    AND?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    OR?: ProductoScalarWhereWithAggregatesInput[]
    NOT?: ProductoScalarWhereWithAggregatesInput | ProductoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Producto"> | number
    nombre?: StringWithAggregatesFilter<"Producto"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Producto"> | string | null
    precio?: DecimalWithAggregatesFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    imagenUrl?: StringNullableWithAggregatesFilter<"Producto"> | string | null
    activo?: BoolWithAggregatesFilter<"Producto"> | boolean
    emprendimientoId?: IntWithAggregatesFilter<"Producto"> | number
  }

  export type RedesSocialesWhereInput = {
    AND?: RedesSocialesWhereInput | RedesSocialesWhereInput[]
    OR?: RedesSocialesWhereInput[]
    NOT?: RedesSocialesWhereInput | RedesSocialesWhereInput[]
    id?: IntFilter<"RedesSociales"> | number
    instagram?: StringNullableFilter<"RedesSociales"> | string | null
    facebook?: StringNullableFilter<"RedesSociales"> | string | null
    tiktok?: StringNullableFilter<"RedesSociales"> | string | null
    whatsapp?: StringNullableFilter<"RedesSociales"> | string | null
    website?: StringNullableFilter<"RedesSociales"> | string | null
    emprendimientoId?: IntFilter<"RedesSociales"> | number
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }

  export type RedesSocialesOrderByWithRelationInput = {
    id?: SortOrder
    instagram?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    tiktok?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    emprendimientoId?: SortOrder
    emprendimiento?: EmprendimientoOrderByWithRelationInput
  }

  export type RedesSocialesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    emprendimientoId?: number
    AND?: RedesSocialesWhereInput | RedesSocialesWhereInput[]
    OR?: RedesSocialesWhereInput[]
    NOT?: RedesSocialesWhereInput | RedesSocialesWhereInput[]
    instagram?: StringNullableFilter<"RedesSociales"> | string | null
    facebook?: StringNullableFilter<"RedesSociales"> | string | null
    tiktok?: StringNullableFilter<"RedesSociales"> | string | null
    whatsapp?: StringNullableFilter<"RedesSociales"> | string | null
    website?: StringNullableFilter<"RedesSociales"> | string | null
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }, "id" | "emprendimientoId">

  export type RedesSocialesOrderByWithAggregationInput = {
    id?: SortOrder
    instagram?: SortOrderInput | SortOrder
    facebook?: SortOrderInput | SortOrder
    tiktok?: SortOrderInput | SortOrder
    whatsapp?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    emprendimientoId?: SortOrder
    _count?: RedesSocialesCountOrderByAggregateInput
    _avg?: RedesSocialesAvgOrderByAggregateInput
    _max?: RedesSocialesMaxOrderByAggregateInput
    _min?: RedesSocialesMinOrderByAggregateInput
    _sum?: RedesSocialesSumOrderByAggregateInput
  }

  export type RedesSocialesScalarWhereWithAggregatesInput = {
    AND?: RedesSocialesScalarWhereWithAggregatesInput | RedesSocialesScalarWhereWithAggregatesInput[]
    OR?: RedesSocialesScalarWhereWithAggregatesInput[]
    NOT?: RedesSocialesScalarWhereWithAggregatesInput | RedesSocialesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RedesSociales"> | number
    instagram?: StringNullableWithAggregatesFilter<"RedesSociales"> | string | null
    facebook?: StringNullableWithAggregatesFilter<"RedesSociales"> | string | null
    tiktok?: StringNullableWithAggregatesFilter<"RedesSociales"> | string | null
    whatsapp?: StringNullableWithAggregatesFilter<"RedesSociales"> | string | null
    website?: StringNullableWithAggregatesFilter<"RedesSociales"> | string | null
    emprendimientoId?: IntWithAggregatesFilter<"RedesSociales"> | number
  }

  export type MentoriaWhereInput = {
    AND?: MentoriaWhereInput | MentoriaWhereInput[]
    OR?: MentoriaWhereInput[]
    NOT?: MentoriaWhereInput | MentoriaWhereInput[]
    id?: IntFilter<"Mentoria"> | number
    tema?: StringFilter<"Mentoria"> | string
    fechaProgramada?: DateTimeFilter<"Mentoria"> | Date | string
    estado?: EnumEstadoMentoriaFilter<"Mentoria"> | $Enums.EstadoMentoria
    notas?: StringNullableFilter<"Mentoria"> | string | null
    tutorId?: IntFilter<"Mentoria"> | number
    emprendimientoId?: IntFilter<"Mentoria"> | number
    tutor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }

  export type MentoriaOrderByWithRelationInput = {
    id?: SortOrder
    tema?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    notas?: SortOrderInput | SortOrder
    tutorId?: SortOrder
    emprendimientoId?: SortOrder
    tutor?: UsuarioOrderByWithRelationInput
    emprendimiento?: EmprendimientoOrderByWithRelationInput
  }

  export type MentoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MentoriaWhereInput | MentoriaWhereInput[]
    OR?: MentoriaWhereInput[]
    NOT?: MentoriaWhereInput | MentoriaWhereInput[]
    tema?: StringFilter<"Mentoria"> | string
    fechaProgramada?: DateTimeFilter<"Mentoria"> | Date | string
    estado?: EnumEstadoMentoriaFilter<"Mentoria"> | $Enums.EstadoMentoria
    notas?: StringNullableFilter<"Mentoria"> | string | null
    tutorId?: IntFilter<"Mentoria"> | number
    emprendimientoId?: IntFilter<"Mentoria"> | number
    tutor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }, "id">

  export type MentoriaOrderByWithAggregationInput = {
    id?: SortOrder
    tema?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    notas?: SortOrderInput | SortOrder
    tutorId?: SortOrder
    emprendimientoId?: SortOrder
    _count?: MentoriaCountOrderByAggregateInput
    _avg?: MentoriaAvgOrderByAggregateInput
    _max?: MentoriaMaxOrderByAggregateInput
    _min?: MentoriaMinOrderByAggregateInput
    _sum?: MentoriaSumOrderByAggregateInput
  }

  export type MentoriaScalarWhereWithAggregatesInput = {
    AND?: MentoriaScalarWhereWithAggregatesInput | MentoriaScalarWhereWithAggregatesInput[]
    OR?: MentoriaScalarWhereWithAggregatesInput[]
    NOT?: MentoriaScalarWhereWithAggregatesInput | MentoriaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mentoria"> | number
    tema?: StringWithAggregatesFilter<"Mentoria"> | string
    fechaProgramada?: DateTimeWithAggregatesFilter<"Mentoria"> | Date | string
    estado?: EnumEstadoMentoriaWithAggregatesFilter<"Mentoria"> | $Enums.EstadoMentoria
    notas?: StringNullableWithAggregatesFilter<"Mentoria"> | string | null
    tutorId?: IntWithAggregatesFilter<"Mentoria"> | number
    emprendimientoId?: IntWithAggregatesFilter<"Mentoria"> | number
  }

  export type ResenaWhereInput = {
    AND?: ResenaWhereInput | ResenaWhereInput[]
    OR?: ResenaWhereInput[]
    NOT?: ResenaWhereInput | ResenaWhereInput[]
    id?: IntFilter<"Resena"> | number
    calificacion?: IntFilter<"Resena"> | number
    comentario?: StringNullableFilter<"Resena"> | string | null
    fecha?: DateTimeFilter<"Resena"> | Date | string
    usuarioId?: IntFilter<"Resena"> | number
    emprendimientoId?: IntFilter<"Resena"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }

  export type ResenaOrderByWithRelationInput = {
    id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrderInput | SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    emprendimiento?: EmprendimientoOrderByWithRelationInput
  }

  export type ResenaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResenaWhereInput | ResenaWhereInput[]
    OR?: ResenaWhereInput[]
    NOT?: ResenaWhereInput | ResenaWhereInput[]
    calificacion?: IntFilter<"Resena"> | number
    comentario?: StringNullableFilter<"Resena"> | string | null
    fecha?: DateTimeFilter<"Resena"> | Date | string
    usuarioId?: IntFilter<"Resena"> | number
    emprendimientoId?: IntFilter<"Resena"> | number
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }, "id">

  export type ResenaOrderByWithAggregationInput = {
    id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrderInput | SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
    _count?: ResenaCountOrderByAggregateInput
    _avg?: ResenaAvgOrderByAggregateInput
    _max?: ResenaMaxOrderByAggregateInput
    _min?: ResenaMinOrderByAggregateInput
    _sum?: ResenaSumOrderByAggregateInput
  }

  export type ResenaScalarWhereWithAggregatesInput = {
    AND?: ResenaScalarWhereWithAggregatesInput | ResenaScalarWhereWithAggregatesInput[]
    OR?: ResenaScalarWhereWithAggregatesInput[]
    NOT?: ResenaScalarWhereWithAggregatesInput | ResenaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resena"> | number
    calificacion?: IntWithAggregatesFilter<"Resena"> | number
    comentario?: StringNullableWithAggregatesFilter<"Resena"> | string | null
    fecha?: DateTimeWithAggregatesFilter<"Resena"> | Date | string
    usuarioId?: IntWithAggregatesFilter<"Resena"> | number
    emprendimientoId?: IntWithAggregatesFilter<"Resena"> | number
  }

  export type PromocionWhereInput = {
    AND?: PromocionWhereInput | PromocionWhereInput[]
    OR?: PromocionWhereInput[]
    NOT?: PromocionWhereInput | PromocionWhereInput[]
    id?: IntFilter<"Promocion"> | number
    titulo?: StringFilter<"Promocion"> | string
    descripcion?: StringNullableFilter<"Promocion"> | string | null
    fechaInicio?: DateTimeFilter<"Promocion"> | Date | string
    fechaFin?: DateTimeFilter<"Promocion"> | Date | string
    descuento?: StringNullableFilter<"Promocion"> | string | null
    activo?: BoolFilter<"Promocion"> | boolean
    emprendimientoId?: IntFilter<"Promocion"> | number
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }

  export type PromocionOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    descuento?: SortOrderInput | SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
    emprendimiento?: EmprendimientoOrderByWithRelationInput
  }

  export type PromocionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PromocionWhereInput | PromocionWhereInput[]
    OR?: PromocionWhereInput[]
    NOT?: PromocionWhereInput | PromocionWhereInput[]
    titulo?: StringFilter<"Promocion"> | string
    descripcion?: StringNullableFilter<"Promocion"> | string | null
    fechaInicio?: DateTimeFilter<"Promocion"> | Date | string
    fechaFin?: DateTimeFilter<"Promocion"> | Date | string
    descuento?: StringNullableFilter<"Promocion"> | string | null
    activo?: BoolFilter<"Promocion"> | boolean
    emprendimientoId?: IntFilter<"Promocion"> | number
    emprendimiento?: XOR<EmprendimientoRelationFilter, EmprendimientoWhereInput>
  }, "id">

  export type PromocionOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    descuento?: SortOrderInput | SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
    _count?: PromocionCountOrderByAggregateInput
    _avg?: PromocionAvgOrderByAggregateInput
    _max?: PromocionMaxOrderByAggregateInput
    _min?: PromocionMinOrderByAggregateInput
    _sum?: PromocionSumOrderByAggregateInput
  }

  export type PromocionScalarWhereWithAggregatesInput = {
    AND?: PromocionScalarWhereWithAggregatesInput | PromocionScalarWhereWithAggregatesInput[]
    OR?: PromocionScalarWhereWithAggregatesInput[]
    NOT?: PromocionScalarWhereWithAggregatesInput | PromocionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Promocion"> | number
    titulo?: StringWithAggregatesFilter<"Promocion"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Promocion"> | string | null
    fechaInicio?: DateTimeWithAggregatesFilter<"Promocion"> | Date | string
    fechaFin?: DateTimeWithAggregatesFilter<"Promocion"> | Date | string
    descuento?: StringNullableWithAggregatesFilter<"Promocion"> | string | null
    activo?: BoolWithAggregatesFilter<"Promocion"> | boolean
    emprendimientoId?: IntWithAggregatesFilter<"Promocion"> | number
  }

  export type UsuarioCreateInput = {
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    roles?: RolCreateNestedManyWithoutUsuariosInput
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    mentoriasComoTutor?: MentoriaCreateNestedManyWithoutTutorInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    roles?: RolUncheckedCreateNestedManyWithoutUsuariosInput
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    mentoriasComoTutor?: MentoriaUncheckedCreateNestedManyWithoutTutorInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    roles?: RolUpdateManyWithoutUsuariosNestedInput
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    mentoriasComoTutor?: MentoriaUpdateManyWithoutTutorNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    roles?: RolUncheckedUpdateManyWithoutUsuariosNestedInput
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    mentoriasComoTutor?: MentoriaUncheckedUpdateManyWithoutTutorNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthCreateInput = {
    password: string
    usuario: UsuarioCreateNestedOneWithoutAuthInput
  }

  export type AuthUncheckedCreateInput = {
    id?: number
    password: string
    usuarioId: number
  }

  export type AuthUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutAuthNestedInput
  }

  export type AuthUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type AuthCreateManyInput = {
    id?: number
    password: string
    usuarioId: number
  }

  export type AuthUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AuthUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type RolCreateInput = {
    nombre: string
    usuarios?: UsuarioCreateNestedManyWithoutRolesInput
  }

  export type RolUncheckedCreateInput = {
    id?: number
    nombre: string
    usuarios?: UsuarioUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    usuarios?: UsuarioUpdateManyWithoutRolesNestedInput
  }

  export type RolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    usuarios?: UsuarioUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RolCreateManyInput = {
    id?: number
    nombre: string
  }

  export type RolUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type CategoriaCreateInput = {
    nombre: string
    descripcion?: string | null
    emprendimientos?: EmprendimientoCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type CategoriaUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    emprendimientos?: EmprendimientoUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type CategoriaCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
  }

  export type CategoriaUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmprendimientoCreateInput = {
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    categoria: CategoriaCreateNestedOneWithoutEmprendimientosInput
    productos?: ProductoCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuarioId: number
    categoriaId: number
    productos?: ProductoUncheckedCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesUncheckedCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaUncheckedCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutEmprendimientosNestedInput
    productos?: ProductoUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuarioId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUncheckedUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuarioId: number
    categoriaId: number
  }

  export type EmprendimientoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
  }

  export type EmprendimientoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuarioId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoCreateInput = {
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagenUrl?: string | null
    activo?: boolean
    emprendimiento: EmprendimientoCreateNestedOneWithoutProductosInput
  }

  export type ProductoUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagenUrl?: string | null
    activo?: boolean
    emprendimientoId: number
  }

  export type ProductoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutProductosNestedInput
  }

  export type ProductoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagenUrl?: string | null
    activo?: boolean
    emprendimientoId: number
  }

  export type ProductoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type RedesSocialesCreateInput = {
    instagram?: string | null
    facebook?: string | null
    tiktok?: string | null
    whatsapp?: string | null
    website?: string | null
    emprendimiento: EmprendimientoCreateNestedOneWithoutRedesSocialesInput
  }

  export type RedesSocialesUncheckedCreateInput = {
    id?: number
    instagram?: string | null
    facebook?: string | null
    tiktok?: string | null
    whatsapp?: string | null
    website?: string | null
    emprendimientoId: number
  }

  export type RedesSocialesUpdateInput = {
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutRedesSocialesNestedInput
  }

  export type RedesSocialesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type RedesSocialesCreateManyInput = {
    id?: number
    instagram?: string | null
    facebook?: string | null
    tiktok?: string | null
    whatsapp?: string | null
    website?: string | null
    emprendimientoId: number
  }

  export type RedesSocialesUpdateManyMutationInput = {
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RedesSocialesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type MentoriaCreateInput = {
    tema: string
    fechaProgramada: Date | string
    estado?: $Enums.EstadoMentoria
    notas?: string | null
    tutor: UsuarioCreateNestedOneWithoutMentoriasComoTutorInput
    emprendimiento: EmprendimientoCreateNestedOneWithoutMentoriasInput
  }

  export type MentoriaUncheckedCreateInput = {
    id?: number
    tema: string
    fechaProgramada: Date | string
    estado?: $Enums.EstadoMentoria
    notas?: string | null
    tutorId: number
    emprendimientoId: number
  }

  export type MentoriaUpdateInput = {
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    tutor?: UsuarioUpdateOneRequiredWithoutMentoriasComoTutorNestedInput
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutMentoriasNestedInput
  }

  export type MentoriaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type MentoriaCreateManyInput = {
    id?: number
    tema: string
    fechaProgramada: Date | string
    estado?: $Enums.EstadoMentoria
    notas?: string | null
    tutorId: number
    emprendimientoId: number
  }

  export type MentoriaUpdateManyMutationInput = {
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentoriaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type ResenaCreateInput = {
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    usuario: UsuarioCreateNestedOneWithoutResenasInput
    emprendimiento: EmprendimientoCreateNestedOneWithoutResenasInput
  }

  export type ResenaUncheckedCreateInput = {
    id?: number
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    usuarioId: number
    emprendimientoId: number
  }

  export type ResenaUpdateInput = {
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutResenasNestedInput
  }

  export type ResenaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type ResenaCreateManyInput = {
    id?: number
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    usuarioId: number
    emprendimientoId: number
  }

  export type ResenaUpdateManyMutationInput = {
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResenaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type PromocionCreateInput = {
    titulo: string
    descripcion?: string | null
    fechaInicio: Date | string
    fechaFin: Date | string
    descuento?: string | null
    activo?: boolean
    emprendimiento: EmprendimientoCreateNestedOneWithoutPromocionesInput
  }

  export type PromocionUncheckedCreateInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaInicio: Date | string
    fechaFin: Date | string
    descuento?: string | null
    activo?: boolean
    emprendimientoId: number
  }

  export type PromocionUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutPromocionesNestedInput
  }

  export type PromocionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type PromocionCreateManyInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaInicio: Date | string
    fechaFin: Date | string
    descuento?: string | null
    activo?: boolean
    emprendimientoId: number
  }

  export type PromocionUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromocionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AuthNullableRelationFilter = {
    is?: AuthWhereInput | null
    isNot?: AuthWhereInput | null
  }

  export type RolListRelationFilter = {
    every?: RolWhereInput
    some?: RolWhereInput
    none?: RolWhereInput
  }

  export type EmprendimientoListRelationFilter = {
    every?: EmprendimientoWhereInput
    some?: EmprendimientoWhereInput
    none?: EmprendimientoWhereInput
  }

  export type MentoriaListRelationFilter = {
    every?: MentoriaWhereInput
    some?: MentoriaWhereInput
    none?: MentoriaWhereInput
  }

  export type ResenaListRelationFilter = {
    every?: ResenaWhereInput
    some?: ResenaWhereInput
    none?: ResenaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmprendimientoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResenaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type AuthCountOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
  }

  export type AuthAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type AuthMaxOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
  }

  export type AuthMinOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    usuarioId?: SortOrder
  }

  export type AuthSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type RolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type RolMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
  }

  export type RolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type CategoriaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type CategoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type CategoriaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEstadoEmprendimientoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEmprendimiento | EnumEstadoEmprendimientoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEmprendimiento[]
    notIn?: $Enums.EstadoEmprendimiento[]
    not?: NestedEnumEstadoEmprendimientoFilter<$PrismaModel> | $Enums.EstadoEmprendimiento
  }

  export type CategoriaRelationFilter = {
    is?: CategoriaWhereInput
    isNot?: CategoriaWhereInput
  }

  export type ProductoListRelationFilter = {
    every?: ProductoWhereInput
    some?: ProductoWhereInput
    none?: ProductoWhereInput
  }

  export type RedesSocialesNullableRelationFilter = {
    is?: RedesSocialesWhereInput | null
    isNot?: RedesSocialesWhereInput | null
  }

  export type PromocionListRelationFilter = {
    every?: PromocionWhereInput
    some?: PromocionWhereInput
    none?: PromocionWhereInput
  }

  export type ProductoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromocionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmprendimientoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    logoUrl?: SortOrder
    fechaCreacion?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    categoriaId?: SortOrder
  }

  export type EmprendimientoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    categoriaId?: SortOrder
  }

  export type EmprendimientoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    logoUrl?: SortOrder
    fechaCreacion?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    categoriaId?: SortOrder
  }

  export type EmprendimientoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    logoUrl?: SortOrder
    fechaCreacion?: SortOrder
    estado?: SortOrder
    usuarioId?: SortOrder
    categoriaId?: SortOrder
  }

  export type EmprendimientoSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    categoriaId?: SortOrder
  }

  export type EnumEstadoEmprendimientoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEmprendimiento | EnumEstadoEmprendimientoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEmprendimiento[]
    notIn?: $Enums.EstadoEmprendimiento[]
    not?: NestedEnumEstadoEmprendimientoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoEmprendimiento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoEmprendimientoFilter<$PrismaModel>
    _max?: NestedEnumEstadoEmprendimientoFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EmprendimientoRelationFilter = {
    is?: EmprendimientoWhereInput
    isNot?: EmprendimientoWhereInput
  }

  export type ProductoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    imagenUrl?: SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ProductoAvgOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ProductoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    imagenUrl?: SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ProductoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    precio?: SortOrder
    imagenUrl?: SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ProductoSumOrderByAggregateInput = {
    id?: SortOrder
    precio?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RedesSocialesCountOrderByAggregateInput = {
    id?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    tiktok?: SortOrder
    whatsapp?: SortOrder
    website?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type RedesSocialesAvgOrderByAggregateInput = {
    id?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type RedesSocialesMaxOrderByAggregateInput = {
    id?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    tiktok?: SortOrder
    whatsapp?: SortOrder
    website?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type RedesSocialesMinOrderByAggregateInput = {
    id?: SortOrder
    instagram?: SortOrder
    facebook?: SortOrder
    tiktok?: SortOrder
    whatsapp?: SortOrder
    website?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type RedesSocialesSumOrderByAggregateInput = {
    id?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type EnumEstadoMentoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoMentoria | EnumEstadoMentoriaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoMentoria[]
    notIn?: $Enums.EstadoMentoria[]
    not?: NestedEnumEstadoMentoriaFilter<$PrismaModel> | $Enums.EstadoMentoria
  }

  export type MentoriaCountOrderByAggregateInput = {
    id?: SortOrder
    tema?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    notas?: SortOrder
    tutorId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type MentoriaAvgOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type MentoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    tema?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    notas?: SortOrder
    tutorId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type MentoriaMinOrderByAggregateInput = {
    id?: SortOrder
    tema?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    notas?: SortOrder
    tutorId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type MentoriaSumOrderByAggregateInput = {
    id?: SortOrder
    tutorId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type EnumEstadoMentoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoMentoria | EnumEstadoMentoriaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoMentoria[]
    notIn?: $Enums.EstadoMentoria[]
    not?: NestedEnumEstadoMentoriaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoMentoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoMentoriaFilter<$PrismaModel>
    _max?: NestedEnumEstadoMentoriaFilter<$PrismaModel>
  }

  export type ResenaCountOrderByAggregateInput = {
    id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ResenaAvgOrderByAggregateInput = {
    id?: SortOrder
    calificacion?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ResenaMaxOrderByAggregateInput = {
    id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ResenaMinOrderByAggregateInput = {
    id?: SortOrder
    calificacion?: SortOrder
    comentario?: SortOrder
    fecha?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type ResenaSumOrderByAggregateInput = {
    id?: SortOrder
    calificacion?: SortOrder
    usuarioId?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type PromocionCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    descuento?: SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type PromocionAvgOrderByAggregateInput = {
    id?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type PromocionMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    descuento?: SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type PromocionMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    descuento?: SortOrder
    activo?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type PromocionSumOrderByAggregateInput = {
    id?: SortOrder
    emprendimientoId?: SortOrder
  }

  export type AuthCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUsuarioInput
    connect?: AuthWhereUniqueInput
  }

  export type RolCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput> | RolCreateWithoutUsuariosInput[] | RolUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput | RolCreateOrConnectWithoutUsuariosInput[]
    connect?: RolWhereUniqueInput | RolWhereUniqueInput[]
  }

  export type EmprendimientoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput> | EmprendimientoCreateWithoutUsuarioInput[] | EmprendimientoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutUsuarioInput | EmprendimientoCreateOrConnectWithoutUsuarioInput[]
    createMany?: EmprendimientoCreateManyUsuarioInputEnvelope
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
  }

  export type MentoriaCreateNestedManyWithoutTutorInput = {
    create?: XOR<MentoriaCreateWithoutTutorInput, MentoriaUncheckedCreateWithoutTutorInput> | MentoriaCreateWithoutTutorInput[] | MentoriaUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: MentoriaCreateOrConnectWithoutTutorInput | MentoriaCreateOrConnectWithoutTutorInput[]
    createMany?: MentoriaCreateManyTutorInputEnvelope
    connect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
  }

  export type ResenaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type AuthUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUsuarioInput
    connect?: AuthWhereUniqueInput
  }

  export type RolUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput> | RolCreateWithoutUsuariosInput[] | RolUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput | RolCreateOrConnectWithoutUsuariosInput[]
    connect?: RolWhereUniqueInput | RolWhereUniqueInput[]
  }

  export type EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput> | EmprendimientoCreateWithoutUsuarioInput[] | EmprendimientoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutUsuarioInput | EmprendimientoCreateOrConnectWithoutUsuarioInput[]
    createMany?: EmprendimientoCreateManyUsuarioInputEnvelope
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
  }

  export type MentoriaUncheckedCreateNestedManyWithoutTutorInput = {
    create?: XOR<MentoriaCreateWithoutTutorInput, MentoriaUncheckedCreateWithoutTutorInput> | MentoriaCreateWithoutTutorInput[] | MentoriaUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: MentoriaCreateOrConnectWithoutTutorInput | MentoriaCreateOrConnectWithoutTutorInput[]
    createMany?: MentoriaCreateManyTutorInputEnvelope
    connect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
  }

  export type ResenaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AuthUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUsuarioInput
    upsert?: AuthUpsertWithoutUsuarioInput
    disconnect?: AuthWhereInput | boolean
    delete?: AuthWhereInput | boolean
    connect?: AuthWhereUniqueInput
    update?: XOR<XOR<AuthUpdateToOneWithWhereWithoutUsuarioInput, AuthUpdateWithoutUsuarioInput>, AuthUncheckedUpdateWithoutUsuarioInput>
  }

  export type RolUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput> | RolCreateWithoutUsuariosInput[] | RolUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput | RolCreateOrConnectWithoutUsuariosInput[]
    upsert?: RolUpsertWithWhereUniqueWithoutUsuariosInput | RolUpsertWithWhereUniqueWithoutUsuariosInput[]
    set?: RolWhereUniqueInput | RolWhereUniqueInput[]
    disconnect?: RolWhereUniqueInput | RolWhereUniqueInput[]
    delete?: RolWhereUniqueInput | RolWhereUniqueInput[]
    connect?: RolWhereUniqueInput | RolWhereUniqueInput[]
    update?: RolUpdateWithWhereUniqueWithoutUsuariosInput | RolUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: RolUpdateManyWithWhereWithoutUsuariosInput | RolUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: RolScalarWhereInput | RolScalarWhereInput[]
  }

  export type EmprendimientoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput> | EmprendimientoCreateWithoutUsuarioInput[] | EmprendimientoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutUsuarioInput | EmprendimientoCreateOrConnectWithoutUsuarioInput[]
    upsert?: EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput | EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EmprendimientoCreateManyUsuarioInputEnvelope
    set?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    disconnect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    delete?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    update?: EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput | EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EmprendimientoUpdateManyWithWhereWithoutUsuarioInput | EmprendimientoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
  }

  export type MentoriaUpdateManyWithoutTutorNestedInput = {
    create?: XOR<MentoriaCreateWithoutTutorInput, MentoriaUncheckedCreateWithoutTutorInput> | MentoriaCreateWithoutTutorInput[] | MentoriaUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: MentoriaCreateOrConnectWithoutTutorInput | MentoriaCreateOrConnectWithoutTutorInput[]
    upsert?: MentoriaUpsertWithWhereUniqueWithoutTutorInput | MentoriaUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: MentoriaCreateManyTutorInputEnvelope
    set?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    disconnect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    delete?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    connect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    update?: MentoriaUpdateWithWhereUniqueWithoutTutorInput | MentoriaUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: MentoriaUpdateManyWithWhereWithoutTutorInput | MentoriaUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: MentoriaScalarWhereInput | MentoriaScalarWhereInput[]
  }

  export type ResenaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutUsuarioInput | ResenaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutUsuarioInput | ResenaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutUsuarioInput | ResenaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AuthUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AuthCreateOrConnectWithoutUsuarioInput
    upsert?: AuthUpsertWithoutUsuarioInput
    disconnect?: AuthWhereInput | boolean
    delete?: AuthWhereInput | boolean
    connect?: AuthWhereUniqueInput
    update?: XOR<XOR<AuthUpdateToOneWithWhereWithoutUsuarioInput, AuthUpdateWithoutUsuarioInput>, AuthUncheckedUpdateWithoutUsuarioInput>
  }

  export type RolUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput> | RolCreateWithoutUsuariosInput[] | RolUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: RolCreateOrConnectWithoutUsuariosInput | RolCreateOrConnectWithoutUsuariosInput[]
    upsert?: RolUpsertWithWhereUniqueWithoutUsuariosInput | RolUpsertWithWhereUniqueWithoutUsuariosInput[]
    set?: RolWhereUniqueInput | RolWhereUniqueInput[]
    disconnect?: RolWhereUniqueInput | RolWhereUniqueInput[]
    delete?: RolWhereUniqueInput | RolWhereUniqueInput[]
    connect?: RolWhereUniqueInput | RolWhereUniqueInput[]
    update?: RolUpdateWithWhereUniqueWithoutUsuariosInput | RolUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: RolUpdateManyWithWhereWithoutUsuariosInput | RolUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: RolScalarWhereInput | RolScalarWhereInput[]
  }

  export type EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput> | EmprendimientoCreateWithoutUsuarioInput[] | EmprendimientoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutUsuarioInput | EmprendimientoCreateOrConnectWithoutUsuarioInput[]
    upsert?: EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput | EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EmprendimientoCreateManyUsuarioInputEnvelope
    set?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    disconnect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    delete?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    update?: EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput | EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EmprendimientoUpdateManyWithWhereWithoutUsuarioInput | EmprendimientoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
  }

  export type MentoriaUncheckedUpdateManyWithoutTutorNestedInput = {
    create?: XOR<MentoriaCreateWithoutTutorInput, MentoriaUncheckedCreateWithoutTutorInput> | MentoriaCreateWithoutTutorInput[] | MentoriaUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: MentoriaCreateOrConnectWithoutTutorInput | MentoriaCreateOrConnectWithoutTutorInput[]
    upsert?: MentoriaUpsertWithWhereUniqueWithoutTutorInput | MentoriaUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: MentoriaCreateManyTutorInputEnvelope
    set?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    disconnect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    delete?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    connect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    update?: MentoriaUpdateWithWhereUniqueWithoutTutorInput | MentoriaUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: MentoriaUpdateManyWithWhereWithoutTutorInput | MentoriaUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: MentoriaScalarWhereInput | MentoriaScalarWhereInput[]
  }

  export type ResenaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput> | ResenaCreateWithoutUsuarioInput[] | ResenaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutUsuarioInput | ResenaCreateOrConnectWithoutUsuarioInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutUsuarioInput | ResenaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ResenaCreateManyUsuarioInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutUsuarioInput | ResenaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutUsuarioInput | ResenaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutAuthInput = {
    create?: XOR<UsuarioCreateWithoutAuthInput, UsuarioUncheckedCreateWithoutAuthInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAuthInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutAuthNestedInput = {
    create?: XOR<UsuarioCreateWithoutAuthInput, UsuarioUncheckedCreateWithoutAuthInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAuthInput
    upsert?: UsuarioUpsertWithoutAuthInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutAuthInput, UsuarioUpdateWithoutAuthInput>, UsuarioUncheckedUpdateWithoutAuthInput>
  }

  export type UsuarioCreateNestedManyWithoutRolesInput = {
    create?: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput> | UsuarioCreateWithoutRolesInput[] | UsuarioUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolesInput | UsuarioCreateOrConnectWithoutRolesInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput> | UsuarioCreateWithoutRolesInput[] | UsuarioUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolesInput | UsuarioCreateOrConnectWithoutRolesInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type UsuarioUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput> | UsuarioCreateWithoutRolesInput[] | UsuarioUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolesInput | UsuarioCreateOrConnectWithoutRolesInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutRolesInput | UsuarioUpsertWithWhereUniqueWithoutRolesInput[]
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutRolesInput | UsuarioUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutRolesInput | UsuarioUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput> | UsuarioCreateWithoutRolesInput[] | UsuarioUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutRolesInput | UsuarioCreateOrConnectWithoutRolesInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutRolesInput | UsuarioUpsertWithWhereUniqueWithoutRolesInput[]
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutRolesInput | UsuarioUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutRolesInput | UsuarioUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type EmprendimientoCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<EmprendimientoCreateWithoutCategoriaInput, EmprendimientoUncheckedCreateWithoutCategoriaInput> | EmprendimientoCreateWithoutCategoriaInput[] | EmprendimientoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutCategoriaInput | EmprendimientoCreateOrConnectWithoutCategoriaInput[]
    createMany?: EmprendimientoCreateManyCategoriaInputEnvelope
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
  }

  export type EmprendimientoUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<EmprendimientoCreateWithoutCategoriaInput, EmprendimientoUncheckedCreateWithoutCategoriaInput> | EmprendimientoCreateWithoutCategoriaInput[] | EmprendimientoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutCategoriaInput | EmprendimientoCreateOrConnectWithoutCategoriaInput[]
    createMany?: EmprendimientoCreateManyCategoriaInputEnvelope
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
  }

  export type EmprendimientoUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutCategoriaInput, EmprendimientoUncheckedCreateWithoutCategoriaInput> | EmprendimientoCreateWithoutCategoriaInput[] | EmprendimientoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutCategoriaInput | EmprendimientoCreateOrConnectWithoutCategoriaInput[]
    upsert?: EmprendimientoUpsertWithWhereUniqueWithoutCategoriaInput | EmprendimientoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: EmprendimientoCreateManyCategoriaInputEnvelope
    set?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    disconnect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    delete?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    update?: EmprendimientoUpdateWithWhereUniqueWithoutCategoriaInput | EmprendimientoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: EmprendimientoUpdateManyWithWhereWithoutCategoriaInput | EmprendimientoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
  }

  export type EmprendimientoUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutCategoriaInput, EmprendimientoUncheckedCreateWithoutCategoriaInput> | EmprendimientoCreateWithoutCategoriaInput[] | EmprendimientoUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutCategoriaInput | EmprendimientoCreateOrConnectWithoutCategoriaInput[]
    upsert?: EmprendimientoUpsertWithWhereUniqueWithoutCategoriaInput | EmprendimientoUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: EmprendimientoCreateManyCategoriaInputEnvelope
    set?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    disconnect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    delete?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    connect?: EmprendimientoWhereUniqueInput | EmprendimientoWhereUniqueInput[]
    update?: EmprendimientoUpdateWithWhereUniqueWithoutCategoriaInput | EmprendimientoUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: EmprendimientoUpdateManyWithWhereWithoutCategoriaInput | EmprendimientoUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutEmprendimientosInput = {
    create?: XOR<UsuarioCreateWithoutEmprendimientosInput, UsuarioUncheckedCreateWithoutEmprendimientosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEmprendimientosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type CategoriaCreateNestedOneWithoutEmprendimientosInput = {
    create?: XOR<CategoriaCreateWithoutEmprendimientosInput, CategoriaUncheckedCreateWithoutEmprendimientosInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutEmprendimientosInput
    connect?: CategoriaWhereUniqueInput
  }

  export type ProductoCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<ProductoCreateWithoutEmprendimientoInput, ProductoUncheckedCreateWithoutEmprendimientoInput> | ProductoCreateWithoutEmprendimientoInput[] | ProductoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutEmprendimientoInput | ProductoCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: ProductoCreateManyEmprendimientoInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type RedesSocialesCreateNestedOneWithoutEmprendimientoInput = {
    create?: XOR<RedesSocialesCreateWithoutEmprendimientoInput, RedesSocialesUncheckedCreateWithoutEmprendimientoInput>
    connectOrCreate?: RedesSocialesCreateOrConnectWithoutEmprendimientoInput
    connect?: RedesSocialesWhereUniqueInput
  }

  export type MentoriaCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<MentoriaCreateWithoutEmprendimientoInput, MentoriaUncheckedCreateWithoutEmprendimientoInput> | MentoriaCreateWithoutEmprendimientoInput[] | MentoriaUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: MentoriaCreateOrConnectWithoutEmprendimientoInput | MentoriaCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: MentoriaCreateManyEmprendimientoInputEnvelope
    connect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
  }

  export type ResenaCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<ResenaCreateWithoutEmprendimientoInput, ResenaUncheckedCreateWithoutEmprendimientoInput> | ResenaCreateWithoutEmprendimientoInput[] | ResenaUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutEmprendimientoInput | ResenaCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: ResenaCreateManyEmprendimientoInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type PromocionCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<PromocionCreateWithoutEmprendimientoInput, PromocionUncheckedCreateWithoutEmprendimientoInput> | PromocionCreateWithoutEmprendimientoInput[] | PromocionUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutEmprendimientoInput | PromocionCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: PromocionCreateManyEmprendimientoInputEnvelope
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
  }

  export type ProductoUncheckedCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<ProductoCreateWithoutEmprendimientoInput, ProductoUncheckedCreateWithoutEmprendimientoInput> | ProductoCreateWithoutEmprendimientoInput[] | ProductoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutEmprendimientoInput | ProductoCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: ProductoCreateManyEmprendimientoInputEnvelope
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
  }

  export type RedesSocialesUncheckedCreateNestedOneWithoutEmprendimientoInput = {
    create?: XOR<RedesSocialesCreateWithoutEmprendimientoInput, RedesSocialesUncheckedCreateWithoutEmprendimientoInput>
    connectOrCreate?: RedesSocialesCreateOrConnectWithoutEmprendimientoInput
    connect?: RedesSocialesWhereUniqueInput
  }

  export type MentoriaUncheckedCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<MentoriaCreateWithoutEmprendimientoInput, MentoriaUncheckedCreateWithoutEmprendimientoInput> | MentoriaCreateWithoutEmprendimientoInput[] | MentoriaUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: MentoriaCreateOrConnectWithoutEmprendimientoInput | MentoriaCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: MentoriaCreateManyEmprendimientoInputEnvelope
    connect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
  }

  export type ResenaUncheckedCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<ResenaCreateWithoutEmprendimientoInput, ResenaUncheckedCreateWithoutEmprendimientoInput> | ResenaCreateWithoutEmprendimientoInput[] | ResenaUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutEmprendimientoInput | ResenaCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: ResenaCreateManyEmprendimientoInputEnvelope
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
  }

  export type PromocionUncheckedCreateNestedManyWithoutEmprendimientoInput = {
    create?: XOR<PromocionCreateWithoutEmprendimientoInput, PromocionUncheckedCreateWithoutEmprendimientoInput> | PromocionCreateWithoutEmprendimientoInput[] | PromocionUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutEmprendimientoInput | PromocionCreateOrConnectWithoutEmprendimientoInput[]
    createMany?: PromocionCreateManyEmprendimientoInputEnvelope
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
  }

  export type EnumEstadoEmprendimientoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoEmprendimiento
  }

  export type UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput = {
    create?: XOR<UsuarioCreateWithoutEmprendimientosInput, UsuarioUncheckedCreateWithoutEmprendimientosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEmprendimientosInput
    upsert?: UsuarioUpsertWithoutEmprendimientosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEmprendimientosInput, UsuarioUpdateWithoutEmprendimientosInput>, UsuarioUncheckedUpdateWithoutEmprendimientosInput>
  }

  export type CategoriaUpdateOneRequiredWithoutEmprendimientosNestedInput = {
    create?: XOR<CategoriaCreateWithoutEmprendimientosInput, CategoriaUncheckedCreateWithoutEmprendimientosInput>
    connectOrCreate?: CategoriaCreateOrConnectWithoutEmprendimientosInput
    upsert?: CategoriaUpsertWithoutEmprendimientosInput
    connect?: CategoriaWhereUniqueInput
    update?: XOR<XOR<CategoriaUpdateToOneWithWhereWithoutEmprendimientosInput, CategoriaUpdateWithoutEmprendimientosInput>, CategoriaUncheckedUpdateWithoutEmprendimientosInput>
  }

  export type ProductoUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<ProductoCreateWithoutEmprendimientoInput, ProductoUncheckedCreateWithoutEmprendimientoInput> | ProductoCreateWithoutEmprendimientoInput[] | ProductoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutEmprendimientoInput | ProductoCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutEmprendimientoInput | ProductoUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: ProductoCreateManyEmprendimientoInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutEmprendimientoInput | ProductoUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutEmprendimientoInput | ProductoUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type RedesSocialesUpdateOneWithoutEmprendimientoNestedInput = {
    create?: XOR<RedesSocialesCreateWithoutEmprendimientoInput, RedesSocialesUncheckedCreateWithoutEmprendimientoInput>
    connectOrCreate?: RedesSocialesCreateOrConnectWithoutEmprendimientoInput
    upsert?: RedesSocialesUpsertWithoutEmprendimientoInput
    disconnect?: RedesSocialesWhereInput | boolean
    delete?: RedesSocialesWhereInput | boolean
    connect?: RedesSocialesWhereUniqueInput
    update?: XOR<XOR<RedesSocialesUpdateToOneWithWhereWithoutEmprendimientoInput, RedesSocialesUpdateWithoutEmprendimientoInput>, RedesSocialesUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type MentoriaUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<MentoriaCreateWithoutEmprendimientoInput, MentoriaUncheckedCreateWithoutEmprendimientoInput> | MentoriaCreateWithoutEmprendimientoInput[] | MentoriaUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: MentoriaCreateOrConnectWithoutEmprendimientoInput | MentoriaCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: MentoriaUpsertWithWhereUniqueWithoutEmprendimientoInput | MentoriaUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: MentoriaCreateManyEmprendimientoInputEnvelope
    set?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    disconnect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    delete?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    connect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    update?: MentoriaUpdateWithWhereUniqueWithoutEmprendimientoInput | MentoriaUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: MentoriaUpdateManyWithWhereWithoutEmprendimientoInput | MentoriaUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: MentoriaScalarWhereInput | MentoriaScalarWhereInput[]
  }

  export type ResenaUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<ResenaCreateWithoutEmprendimientoInput, ResenaUncheckedCreateWithoutEmprendimientoInput> | ResenaCreateWithoutEmprendimientoInput[] | ResenaUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutEmprendimientoInput | ResenaCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutEmprendimientoInput | ResenaUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: ResenaCreateManyEmprendimientoInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutEmprendimientoInput | ResenaUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutEmprendimientoInput | ResenaUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type PromocionUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<PromocionCreateWithoutEmprendimientoInput, PromocionUncheckedCreateWithoutEmprendimientoInput> | PromocionCreateWithoutEmprendimientoInput[] | PromocionUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutEmprendimientoInput | PromocionCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: PromocionUpsertWithWhereUniqueWithoutEmprendimientoInput | PromocionUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: PromocionCreateManyEmprendimientoInputEnvelope
    set?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    disconnect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    delete?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    update?: PromocionUpdateWithWhereUniqueWithoutEmprendimientoInput | PromocionUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: PromocionUpdateManyWithWhereWithoutEmprendimientoInput | PromocionUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
  }

  export type ProductoUncheckedUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<ProductoCreateWithoutEmprendimientoInput, ProductoUncheckedCreateWithoutEmprendimientoInput> | ProductoCreateWithoutEmprendimientoInput[] | ProductoUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ProductoCreateOrConnectWithoutEmprendimientoInput | ProductoCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: ProductoUpsertWithWhereUniqueWithoutEmprendimientoInput | ProductoUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: ProductoCreateManyEmprendimientoInputEnvelope
    set?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    disconnect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    delete?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    connect?: ProductoWhereUniqueInput | ProductoWhereUniqueInput[]
    update?: ProductoUpdateWithWhereUniqueWithoutEmprendimientoInput | ProductoUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: ProductoUpdateManyWithWhereWithoutEmprendimientoInput | ProductoUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
  }

  export type RedesSocialesUncheckedUpdateOneWithoutEmprendimientoNestedInput = {
    create?: XOR<RedesSocialesCreateWithoutEmprendimientoInput, RedesSocialesUncheckedCreateWithoutEmprendimientoInput>
    connectOrCreate?: RedesSocialesCreateOrConnectWithoutEmprendimientoInput
    upsert?: RedesSocialesUpsertWithoutEmprendimientoInput
    disconnect?: RedesSocialesWhereInput | boolean
    delete?: RedesSocialesWhereInput | boolean
    connect?: RedesSocialesWhereUniqueInput
    update?: XOR<XOR<RedesSocialesUpdateToOneWithWhereWithoutEmprendimientoInput, RedesSocialesUpdateWithoutEmprendimientoInput>, RedesSocialesUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type MentoriaUncheckedUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<MentoriaCreateWithoutEmprendimientoInput, MentoriaUncheckedCreateWithoutEmprendimientoInput> | MentoriaCreateWithoutEmprendimientoInput[] | MentoriaUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: MentoriaCreateOrConnectWithoutEmprendimientoInput | MentoriaCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: MentoriaUpsertWithWhereUniqueWithoutEmprendimientoInput | MentoriaUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: MentoriaCreateManyEmprendimientoInputEnvelope
    set?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    disconnect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    delete?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    connect?: MentoriaWhereUniqueInput | MentoriaWhereUniqueInput[]
    update?: MentoriaUpdateWithWhereUniqueWithoutEmprendimientoInput | MentoriaUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: MentoriaUpdateManyWithWhereWithoutEmprendimientoInput | MentoriaUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: MentoriaScalarWhereInput | MentoriaScalarWhereInput[]
  }

  export type ResenaUncheckedUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<ResenaCreateWithoutEmprendimientoInput, ResenaUncheckedCreateWithoutEmprendimientoInput> | ResenaCreateWithoutEmprendimientoInput[] | ResenaUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: ResenaCreateOrConnectWithoutEmprendimientoInput | ResenaCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: ResenaUpsertWithWhereUniqueWithoutEmprendimientoInput | ResenaUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: ResenaCreateManyEmprendimientoInputEnvelope
    set?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    disconnect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    delete?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    connect?: ResenaWhereUniqueInput | ResenaWhereUniqueInput[]
    update?: ResenaUpdateWithWhereUniqueWithoutEmprendimientoInput | ResenaUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: ResenaUpdateManyWithWhereWithoutEmprendimientoInput | ResenaUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
  }

  export type PromocionUncheckedUpdateManyWithoutEmprendimientoNestedInput = {
    create?: XOR<PromocionCreateWithoutEmprendimientoInput, PromocionUncheckedCreateWithoutEmprendimientoInput> | PromocionCreateWithoutEmprendimientoInput[] | PromocionUncheckedCreateWithoutEmprendimientoInput[]
    connectOrCreate?: PromocionCreateOrConnectWithoutEmprendimientoInput | PromocionCreateOrConnectWithoutEmprendimientoInput[]
    upsert?: PromocionUpsertWithWhereUniqueWithoutEmprendimientoInput | PromocionUpsertWithWhereUniqueWithoutEmprendimientoInput[]
    createMany?: PromocionCreateManyEmprendimientoInputEnvelope
    set?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    disconnect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    delete?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    connect?: PromocionWhereUniqueInput | PromocionWhereUniqueInput[]
    update?: PromocionUpdateWithWhereUniqueWithoutEmprendimientoInput | PromocionUpdateWithWhereUniqueWithoutEmprendimientoInput[]
    updateMany?: PromocionUpdateManyWithWhereWithoutEmprendimientoInput | PromocionUpdateManyWithWhereWithoutEmprendimientoInput[]
    deleteMany?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
  }

  export type EmprendimientoCreateNestedOneWithoutProductosInput = {
    create?: XOR<EmprendimientoCreateWithoutProductosInput, EmprendimientoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutProductosInput
    connect?: EmprendimientoWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EmprendimientoUpdateOneRequiredWithoutProductosNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutProductosInput, EmprendimientoUncheckedCreateWithoutProductosInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutProductosInput
    upsert?: EmprendimientoUpsertWithoutProductosInput
    connect?: EmprendimientoWhereUniqueInput
    update?: XOR<XOR<EmprendimientoUpdateToOneWithWhereWithoutProductosInput, EmprendimientoUpdateWithoutProductosInput>, EmprendimientoUncheckedUpdateWithoutProductosInput>
  }

  export type EmprendimientoCreateNestedOneWithoutRedesSocialesInput = {
    create?: XOR<EmprendimientoCreateWithoutRedesSocialesInput, EmprendimientoUncheckedCreateWithoutRedesSocialesInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutRedesSocialesInput
    connect?: EmprendimientoWhereUniqueInput
  }

  export type EmprendimientoUpdateOneRequiredWithoutRedesSocialesNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutRedesSocialesInput, EmprendimientoUncheckedCreateWithoutRedesSocialesInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutRedesSocialesInput
    upsert?: EmprendimientoUpsertWithoutRedesSocialesInput
    connect?: EmprendimientoWhereUniqueInput
    update?: XOR<XOR<EmprendimientoUpdateToOneWithWhereWithoutRedesSocialesInput, EmprendimientoUpdateWithoutRedesSocialesInput>, EmprendimientoUncheckedUpdateWithoutRedesSocialesInput>
  }

  export type UsuarioCreateNestedOneWithoutMentoriasComoTutorInput = {
    create?: XOR<UsuarioCreateWithoutMentoriasComoTutorInput, UsuarioUncheckedCreateWithoutMentoriasComoTutorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMentoriasComoTutorInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EmprendimientoCreateNestedOneWithoutMentoriasInput = {
    create?: XOR<EmprendimientoCreateWithoutMentoriasInput, EmprendimientoUncheckedCreateWithoutMentoriasInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutMentoriasInput
    connect?: EmprendimientoWhereUniqueInput
  }

  export type EnumEstadoMentoriaFieldUpdateOperationsInput = {
    set?: $Enums.EstadoMentoria
  }

  export type UsuarioUpdateOneRequiredWithoutMentoriasComoTutorNestedInput = {
    create?: XOR<UsuarioCreateWithoutMentoriasComoTutorInput, UsuarioUncheckedCreateWithoutMentoriasComoTutorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutMentoriasComoTutorInput
    upsert?: UsuarioUpsertWithoutMentoriasComoTutorInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutMentoriasComoTutorInput, UsuarioUpdateWithoutMentoriasComoTutorInput>, UsuarioUncheckedUpdateWithoutMentoriasComoTutorInput>
  }

  export type EmprendimientoUpdateOneRequiredWithoutMentoriasNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutMentoriasInput, EmprendimientoUncheckedCreateWithoutMentoriasInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutMentoriasInput
    upsert?: EmprendimientoUpsertWithoutMentoriasInput
    connect?: EmprendimientoWhereUniqueInput
    update?: XOR<XOR<EmprendimientoUpdateToOneWithWhereWithoutMentoriasInput, EmprendimientoUpdateWithoutMentoriasInput>, EmprendimientoUncheckedUpdateWithoutMentoriasInput>
  }

  export type UsuarioCreateNestedOneWithoutResenasInput = {
    create?: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenasInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EmprendimientoCreateNestedOneWithoutResenasInput = {
    create?: XOR<EmprendimientoCreateWithoutResenasInput, EmprendimientoUncheckedCreateWithoutResenasInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutResenasInput
    connect?: EmprendimientoWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutResenasNestedInput = {
    create?: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutResenasInput
    upsert?: UsuarioUpsertWithoutResenasInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutResenasInput, UsuarioUpdateWithoutResenasInput>, UsuarioUncheckedUpdateWithoutResenasInput>
  }

  export type EmprendimientoUpdateOneRequiredWithoutResenasNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutResenasInput, EmprendimientoUncheckedCreateWithoutResenasInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutResenasInput
    upsert?: EmprendimientoUpsertWithoutResenasInput
    connect?: EmprendimientoWhereUniqueInput
    update?: XOR<XOR<EmprendimientoUpdateToOneWithWhereWithoutResenasInput, EmprendimientoUpdateWithoutResenasInput>, EmprendimientoUncheckedUpdateWithoutResenasInput>
  }

  export type EmprendimientoCreateNestedOneWithoutPromocionesInput = {
    create?: XOR<EmprendimientoCreateWithoutPromocionesInput, EmprendimientoUncheckedCreateWithoutPromocionesInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutPromocionesInput
    connect?: EmprendimientoWhereUniqueInput
  }

  export type EmprendimientoUpdateOneRequiredWithoutPromocionesNestedInput = {
    create?: XOR<EmprendimientoCreateWithoutPromocionesInput, EmprendimientoUncheckedCreateWithoutPromocionesInput>
    connectOrCreate?: EmprendimientoCreateOrConnectWithoutPromocionesInput
    upsert?: EmprendimientoUpsertWithoutPromocionesInput
    connect?: EmprendimientoWhereUniqueInput
    update?: XOR<XOR<EmprendimientoUpdateToOneWithWhereWithoutPromocionesInput, EmprendimientoUpdateWithoutPromocionesInput>, EmprendimientoUncheckedUpdateWithoutPromocionesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumEstadoEmprendimientoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEmprendimiento | EnumEstadoEmprendimientoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEmprendimiento[]
    notIn?: $Enums.EstadoEmprendimiento[]
    not?: NestedEnumEstadoEmprendimientoFilter<$PrismaModel> | $Enums.EstadoEmprendimiento
  }

  export type NestedEnumEstadoEmprendimientoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoEmprendimiento | EnumEstadoEmprendimientoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoEmprendimiento[]
    notIn?: $Enums.EstadoEmprendimiento[]
    not?: NestedEnumEstadoEmprendimientoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoEmprendimiento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoEmprendimientoFilter<$PrismaModel>
    _max?: NestedEnumEstadoEmprendimientoFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumEstadoMentoriaFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoMentoria | EnumEstadoMentoriaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoMentoria[]
    notIn?: $Enums.EstadoMentoria[]
    not?: NestedEnumEstadoMentoriaFilter<$PrismaModel> | $Enums.EstadoMentoria
  }

  export type NestedEnumEstadoMentoriaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoMentoria | EnumEstadoMentoriaFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoMentoria[]
    notIn?: $Enums.EstadoMentoria[]
    not?: NestedEnumEstadoMentoriaWithAggregatesFilter<$PrismaModel> | $Enums.EstadoMentoria
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoMentoriaFilter<$PrismaModel>
    _max?: NestedEnumEstadoMentoriaFilter<$PrismaModel>
  }

  export type AuthCreateWithoutUsuarioInput = {
    password: string
  }

  export type AuthUncheckedCreateWithoutUsuarioInput = {
    id?: number
    password: string
  }

  export type AuthCreateOrConnectWithoutUsuarioInput = {
    where: AuthWhereUniqueInput
    create: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
  }

  export type RolCreateWithoutUsuariosInput = {
    nombre: string
  }

  export type RolUncheckedCreateWithoutUsuariosInput = {
    id?: number
    nombre: string
  }

  export type RolCreateOrConnectWithoutUsuariosInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
  }

  export type EmprendimientoCreateWithoutUsuarioInput = {
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    categoria: CategoriaCreateNestedOneWithoutEmprendimientosInput
    productos?: ProductoCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    categoriaId: number
    productos?: ProductoUncheckedCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesUncheckedCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaUncheckedCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutUsuarioInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput>
  }

  export type EmprendimientoCreateManyUsuarioInputEnvelope = {
    data: EmprendimientoCreateManyUsuarioInput | EmprendimientoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type MentoriaCreateWithoutTutorInput = {
    tema: string
    fechaProgramada: Date | string
    estado?: $Enums.EstadoMentoria
    notas?: string | null
    emprendimiento: EmprendimientoCreateNestedOneWithoutMentoriasInput
  }

  export type MentoriaUncheckedCreateWithoutTutorInput = {
    id?: number
    tema: string
    fechaProgramada: Date | string
    estado?: $Enums.EstadoMentoria
    notas?: string | null
    emprendimientoId: number
  }

  export type MentoriaCreateOrConnectWithoutTutorInput = {
    where: MentoriaWhereUniqueInput
    create: XOR<MentoriaCreateWithoutTutorInput, MentoriaUncheckedCreateWithoutTutorInput>
  }

  export type MentoriaCreateManyTutorInputEnvelope = {
    data: MentoriaCreateManyTutorInput | MentoriaCreateManyTutorInput[]
    skipDuplicates?: boolean
  }

  export type ResenaCreateWithoutUsuarioInput = {
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    emprendimiento: EmprendimientoCreateNestedOneWithoutResenasInput
  }

  export type ResenaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    emprendimientoId: number
  }

  export type ResenaCreateOrConnectWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput
    create: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput>
  }

  export type ResenaCreateManyUsuarioInputEnvelope = {
    data: ResenaCreateManyUsuarioInput | ResenaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type AuthUpsertWithoutUsuarioInput = {
    update: XOR<AuthUpdateWithoutUsuarioInput, AuthUncheckedUpdateWithoutUsuarioInput>
    create: XOR<AuthCreateWithoutUsuarioInput, AuthUncheckedCreateWithoutUsuarioInput>
    where?: AuthWhereInput
  }

  export type AuthUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: AuthWhereInput
    data: XOR<AuthUpdateWithoutUsuarioInput, AuthUncheckedUpdateWithoutUsuarioInput>
  }

  export type AuthUpdateWithoutUsuarioInput = {
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AuthUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
  }

  export type RolUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: RolWhereUniqueInput
    update: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
    create: XOR<RolCreateWithoutUsuariosInput, RolUncheckedCreateWithoutUsuariosInput>
  }

  export type RolUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: RolWhereUniqueInput
    data: XOR<RolUpdateWithoutUsuariosInput, RolUncheckedUpdateWithoutUsuariosInput>
  }

  export type RolUpdateManyWithWhereWithoutUsuariosInput = {
    where: RolScalarWhereInput
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type RolScalarWhereInput = {
    AND?: RolScalarWhereInput | RolScalarWhereInput[]
    OR?: RolScalarWhereInput[]
    NOT?: RolScalarWhereInput | RolScalarWhereInput[]
    id?: IntFilter<"Rol"> | number
    nombre?: StringFilter<"Rol"> | string
  }

  export type EmprendimientoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: EmprendimientoWhereUniqueInput
    update: XOR<EmprendimientoUpdateWithoutUsuarioInput, EmprendimientoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EmprendimientoCreateWithoutUsuarioInput, EmprendimientoUncheckedCreateWithoutUsuarioInput>
  }

  export type EmprendimientoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: EmprendimientoWhereUniqueInput
    data: XOR<EmprendimientoUpdateWithoutUsuarioInput, EmprendimientoUncheckedUpdateWithoutUsuarioInput>
  }

  export type EmprendimientoUpdateManyWithWhereWithoutUsuarioInput = {
    where: EmprendimientoScalarWhereInput
    data: XOR<EmprendimientoUpdateManyMutationInput, EmprendimientoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type EmprendimientoScalarWhereInput = {
    AND?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
    OR?: EmprendimientoScalarWhereInput[]
    NOT?: EmprendimientoScalarWhereInput | EmprendimientoScalarWhereInput[]
    id?: IntFilter<"Emprendimiento"> | number
    nombre?: StringFilter<"Emprendimiento"> | string
    descripcion?: StringNullableFilter<"Emprendimiento"> | string | null
    logoUrl?: StringNullableFilter<"Emprendimiento"> | string | null
    fechaCreacion?: DateTimeFilter<"Emprendimiento"> | Date | string
    estado?: EnumEstadoEmprendimientoFilter<"Emprendimiento"> | $Enums.EstadoEmprendimiento
    usuarioId?: IntFilter<"Emprendimiento"> | number
    categoriaId?: IntFilter<"Emprendimiento"> | number
  }

  export type MentoriaUpsertWithWhereUniqueWithoutTutorInput = {
    where: MentoriaWhereUniqueInput
    update: XOR<MentoriaUpdateWithoutTutorInput, MentoriaUncheckedUpdateWithoutTutorInput>
    create: XOR<MentoriaCreateWithoutTutorInput, MentoriaUncheckedCreateWithoutTutorInput>
  }

  export type MentoriaUpdateWithWhereUniqueWithoutTutorInput = {
    where: MentoriaWhereUniqueInput
    data: XOR<MentoriaUpdateWithoutTutorInput, MentoriaUncheckedUpdateWithoutTutorInput>
  }

  export type MentoriaUpdateManyWithWhereWithoutTutorInput = {
    where: MentoriaScalarWhereInput
    data: XOR<MentoriaUpdateManyMutationInput, MentoriaUncheckedUpdateManyWithoutTutorInput>
  }

  export type MentoriaScalarWhereInput = {
    AND?: MentoriaScalarWhereInput | MentoriaScalarWhereInput[]
    OR?: MentoriaScalarWhereInput[]
    NOT?: MentoriaScalarWhereInput | MentoriaScalarWhereInput[]
    id?: IntFilter<"Mentoria"> | number
    tema?: StringFilter<"Mentoria"> | string
    fechaProgramada?: DateTimeFilter<"Mentoria"> | Date | string
    estado?: EnumEstadoMentoriaFilter<"Mentoria"> | $Enums.EstadoMentoria
    notas?: StringNullableFilter<"Mentoria"> | string | null
    tutorId?: IntFilter<"Mentoria"> | number
    emprendimientoId?: IntFilter<"Mentoria"> | number
  }

  export type ResenaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput
    update: XOR<ResenaUpdateWithoutUsuarioInput, ResenaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ResenaCreateWithoutUsuarioInput, ResenaUncheckedCreateWithoutUsuarioInput>
  }

  export type ResenaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ResenaWhereUniqueInput
    data: XOR<ResenaUpdateWithoutUsuarioInput, ResenaUncheckedUpdateWithoutUsuarioInput>
  }

  export type ResenaUpdateManyWithWhereWithoutUsuarioInput = {
    where: ResenaScalarWhereInput
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ResenaScalarWhereInput = {
    AND?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
    OR?: ResenaScalarWhereInput[]
    NOT?: ResenaScalarWhereInput | ResenaScalarWhereInput[]
    id?: IntFilter<"Resena"> | number
    calificacion?: IntFilter<"Resena"> | number
    comentario?: StringNullableFilter<"Resena"> | string | null
    fecha?: DateTimeFilter<"Resena"> | Date | string
    usuarioId?: IntFilter<"Resena"> | number
    emprendimientoId?: IntFilter<"Resena"> | number
  }

  export type UsuarioCreateWithoutAuthInput = {
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    roles?: RolCreateNestedManyWithoutUsuariosInput
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    mentoriasComoTutor?: MentoriaCreateNestedManyWithoutTutorInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutAuthInput = {
    id?: number
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    roles?: RolUncheckedCreateNestedManyWithoutUsuariosInput
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    mentoriasComoTutor?: MentoriaUncheckedCreateNestedManyWithoutTutorInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutAuthInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAuthInput, UsuarioUncheckedCreateWithoutAuthInput>
  }

  export type UsuarioUpsertWithoutAuthInput = {
    update: XOR<UsuarioUpdateWithoutAuthInput, UsuarioUncheckedUpdateWithoutAuthInput>
    create: XOR<UsuarioCreateWithoutAuthInput, UsuarioUncheckedCreateWithoutAuthInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutAuthInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutAuthInput, UsuarioUncheckedUpdateWithoutAuthInput>
  }

  export type UsuarioUpdateWithoutAuthInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolUpdateManyWithoutUsuariosNestedInput
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    mentoriasComoTutor?: MentoriaUpdateManyWithoutTutorNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAuthInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolUncheckedUpdateManyWithoutUsuariosNestedInput
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    mentoriasComoTutor?: MentoriaUncheckedUpdateManyWithoutTutorNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutRolesInput = {
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    mentoriasComoTutor?: MentoriaCreateNestedManyWithoutTutorInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRolesInput = {
    id?: number
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    mentoriasComoTutor?: MentoriaUncheckedCreateNestedManyWithoutTutorInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRolesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput>
  }

  export type UsuarioUpsertWithWhereUniqueWithoutRolesInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutRolesInput, UsuarioUncheckedUpdateWithoutRolesInput>
    create: XOR<UsuarioCreateWithoutRolesInput, UsuarioUncheckedCreateWithoutRolesInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutRolesInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutRolesInput, UsuarioUncheckedUpdateWithoutRolesInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutRolesInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutRolesInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    telefono?: StringNullableFilter<"Usuario"> | string | null
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
  }

  export type EmprendimientoCreateWithoutCategoriaInput = {
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    productos?: ProductoCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutCategoriaInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuarioId: number
    productos?: ProductoUncheckedCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesUncheckedCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaUncheckedCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutCategoriaInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutCategoriaInput, EmprendimientoUncheckedCreateWithoutCategoriaInput>
  }

  export type EmprendimientoCreateManyCategoriaInputEnvelope = {
    data: EmprendimientoCreateManyCategoriaInput | EmprendimientoCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type EmprendimientoUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: EmprendimientoWhereUniqueInput
    update: XOR<EmprendimientoUpdateWithoutCategoriaInput, EmprendimientoUncheckedUpdateWithoutCategoriaInput>
    create: XOR<EmprendimientoCreateWithoutCategoriaInput, EmprendimientoUncheckedCreateWithoutCategoriaInput>
  }

  export type EmprendimientoUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: EmprendimientoWhereUniqueInput
    data: XOR<EmprendimientoUpdateWithoutCategoriaInput, EmprendimientoUncheckedUpdateWithoutCategoriaInput>
  }

  export type EmprendimientoUpdateManyWithWhereWithoutCategoriaInput = {
    where: EmprendimientoScalarWhereInput
    data: XOR<EmprendimientoUpdateManyMutationInput, EmprendimientoUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type UsuarioCreateWithoutEmprendimientosInput = {
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    roles?: RolCreateNestedManyWithoutUsuariosInput
    mentoriasComoTutor?: MentoriaCreateNestedManyWithoutTutorInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEmprendimientosInput = {
    id?: number
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    roles?: RolUncheckedCreateNestedManyWithoutUsuariosInput
    mentoriasComoTutor?: MentoriaUncheckedCreateNestedManyWithoutTutorInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEmprendimientosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEmprendimientosInput, UsuarioUncheckedCreateWithoutEmprendimientosInput>
  }

  export type CategoriaCreateWithoutEmprendimientosInput = {
    nombre: string
    descripcion?: string | null
  }

  export type CategoriaUncheckedCreateWithoutEmprendimientosInput = {
    id?: number
    nombre: string
    descripcion?: string | null
  }

  export type CategoriaCreateOrConnectWithoutEmprendimientosInput = {
    where: CategoriaWhereUniqueInput
    create: XOR<CategoriaCreateWithoutEmprendimientosInput, CategoriaUncheckedCreateWithoutEmprendimientosInput>
  }

  export type ProductoCreateWithoutEmprendimientoInput = {
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagenUrl?: string | null
    activo?: boolean
  }

  export type ProductoUncheckedCreateWithoutEmprendimientoInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagenUrl?: string | null
    activo?: boolean
  }

  export type ProductoCreateOrConnectWithoutEmprendimientoInput = {
    where: ProductoWhereUniqueInput
    create: XOR<ProductoCreateWithoutEmprendimientoInput, ProductoUncheckedCreateWithoutEmprendimientoInput>
  }

  export type ProductoCreateManyEmprendimientoInputEnvelope = {
    data: ProductoCreateManyEmprendimientoInput | ProductoCreateManyEmprendimientoInput[]
    skipDuplicates?: boolean
  }

  export type RedesSocialesCreateWithoutEmprendimientoInput = {
    instagram?: string | null
    facebook?: string | null
    tiktok?: string | null
    whatsapp?: string | null
    website?: string | null
  }

  export type RedesSocialesUncheckedCreateWithoutEmprendimientoInput = {
    id?: number
    instagram?: string | null
    facebook?: string | null
    tiktok?: string | null
    whatsapp?: string | null
    website?: string | null
  }

  export type RedesSocialesCreateOrConnectWithoutEmprendimientoInput = {
    where: RedesSocialesWhereUniqueInput
    create: XOR<RedesSocialesCreateWithoutEmprendimientoInput, RedesSocialesUncheckedCreateWithoutEmprendimientoInput>
  }

  export type MentoriaCreateWithoutEmprendimientoInput = {
    tema: string
    fechaProgramada: Date | string
    estado?: $Enums.EstadoMentoria
    notas?: string | null
    tutor: UsuarioCreateNestedOneWithoutMentoriasComoTutorInput
  }

  export type MentoriaUncheckedCreateWithoutEmprendimientoInput = {
    id?: number
    tema: string
    fechaProgramada: Date | string
    estado?: $Enums.EstadoMentoria
    notas?: string | null
    tutorId: number
  }

  export type MentoriaCreateOrConnectWithoutEmprendimientoInput = {
    where: MentoriaWhereUniqueInput
    create: XOR<MentoriaCreateWithoutEmprendimientoInput, MentoriaUncheckedCreateWithoutEmprendimientoInput>
  }

  export type MentoriaCreateManyEmprendimientoInputEnvelope = {
    data: MentoriaCreateManyEmprendimientoInput | MentoriaCreateManyEmprendimientoInput[]
    skipDuplicates?: boolean
  }

  export type ResenaCreateWithoutEmprendimientoInput = {
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    usuario: UsuarioCreateNestedOneWithoutResenasInput
  }

  export type ResenaUncheckedCreateWithoutEmprendimientoInput = {
    id?: number
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    usuarioId: number
  }

  export type ResenaCreateOrConnectWithoutEmprendimientoInput = {
    where: ResenaWhereUniqueInput
    create: XOR<ResenaCreateWithoutEmprendimientoInput, ResenaUncheckedCreateWithoutEmprendimientoInput>
  }

  export type ResenaCreateManyEmprendimientoInputEnvelope = {
    data: ResenaCreateManyEmprendimientoInput | ResenaCreateManyEmprendimientoInput[]
    skipDuplicates?: boolean
  }

  export type PromocionCreateWithoutEmprendimientoInput = {
    titulo: string
    descripcion?: string | null
    fechaInicio: Date | string
    fechaFin: Date | string
    descuento?: string | null
    activo?: boolean
  }

  export type PromocionUncheckedCreateWithoutEmprendimientoInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaInicio: Date | string
    fechaFin: Date | string
    descuento?: string | null
    activo?: boolean
  }

  export type PromocionCreateOrConnectWithoutEmprendimientoInput = {
    where: PromocionWhereUniqueInput
    create: XOR<PromocionCreateWithoutEmprendimientoInput, PromocionUncheckedCreateWithoutEmprendimientoInput>
  }

  export type PromocionCreateManyEmprendimientoInputEnvelope = {
    data: PromocionCreateManyEmprendimientoInput | PromocionCreateManyEmprendimientoInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutEmprendimientosInput = {
    update: XOR<UsuarioUpdateWithoutEmprendimientosInput, UsuarioUncheckedUpdateWithoutEmprendimientosInput>
    create: XOR<UsuarioCreateWithoutEmprendimientosInput, UsuarioUncheckedCreateWithoutEmprendimientosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEmprendimientosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEmprendimientosInput, UsuarioUncheckedUpdateWithoutEmprendimientosInput>
  }

  export type UsuarioUpdateWithoutEmprendimientosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    roles?: RolUpdateManyWithoutUsuariosNestedInput
    mentoriasComoTutor?: MentoriaUpdateManyWithoutTutorNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEmprendimientosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    roles?: RolUncheckedUpdateManyWithoutUsuariosNestedInput
    mentoriasComoTutor?: MentoriaUncheckedUpdateManyWithoutTutorNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type CategoriaUpsertWithoutEmprendimientosInput = {
    update: XOR<CategoriaUpdateWithoutEmprendimientosInput, CategoriaUncheckedUpdateWithoutEmprendimientosInput>
    create: XOR<CategoriaCreateWithoutEmprendimientosInput, CategoriaUncheckedCreateWithoutEmprendimientosInput>
    where?: CategoriaWhereInput
  }

  export type CategoriaUpdateToOneWithWhereWithoutEmprendimientosInput = {
    where?: CategoriaWhereInput
    data: XOR<CategoriaUpdateWithoutEmprendimientosInput, CategoriaUncheckedUpdateWithoutEmprendimientosInput>
  }

  export type CategoriaUpdateWithoutEmprendimientosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoriaUncheckedUpdateWithoutEmprendimientosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductoUpsertWithWhereUniqueWithoutEmprendimientoInput = {
    where: ProductoWhereUniqueInput
    update: XOR<ProductoUpdateWithoutEmprendimientoInput, ProductoUncheckedUpdateWithoutEmprendimientoInput>
    create: XOR<ProductoCreateWithoutEmprendimientoInput, ProductoUncheckedCreateWithoutEmprendimientoInput>
  }

  export type ProductoUpdateWithWhereUniqueWithoutEmprendimientoInput = {
    where: ProductoWhereUniqueInput
    data: XOR<ProductoUpdateWithoutEmprendimientoInput, ProductoUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type ProductoUpdateManyWithWhereWithoutEmprendimientoInput = {
    where: ProductoScalarWhereInput
    data: XOR<ProductoUpdateManyMutationInput, ProductoUncheckedUpdateManyWithoutEmprendimientoInput>
  }

  export type ProductoScalarWhereInput = {
    AND?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    OR?: ProductoScalarWhereInput[]
    NOT?: ProductoScalarWhereInput | ProductoScalarWhereInput[]
    id?: IntFilter<"Producto"> | number
    nombre?: StringFilter<"Producto"> | string
    descripcion?: StringNullableFilter<"Producto"> | string | null
    precio?: DecimalFilter<"Producto"> | Decimal | DecimalJsLike | number | string
    imagenUrl?: StringNullableFilter<"Producto"> | string | null
    activo?: BoolFilter<"Producto"> | boolean
    emprendimientoId?: IntFilter<"Producto"> | number
  }

  export type RedesSocialesUpsertWithoutEmprendimientoInput = {
    update: XOR<RedesSocialesUpdateWithoutEmprendimientoInput, RedesSocialesUncheckedUpdateWithoutEmprendimientoInput>
    create: XOR<RedesSocialesCreateWithoutEmprendimientoInput, RedesSocialesUncheckedCreateWithoutEmprendimientoInput>
    where?: RedesSocialesWhereInput
  }

  export type RedesSocialesUpdateToOneWithWhereWithoutEmprendimientoInput = {
    where?: RedesSocialesWhereInput
    data: XOR<RedesSocialesUpdateWithoutEmprendimientoInput, RedesSocialesUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type RedesSocialesUpdateWithoutEmprendimientoInput = {
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RedesSocialesUncheckedUpdateWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    facebook?: NullableStringFieldUpdateOperationsInput | string | null
    tiktok?: NullableStringFieldUpdateOperationsInput | string | null
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentoriaUpsertWithWhereUniqueWithoutEmprendimientoInput = {
    where: MentoriaWhereUniqueInput
    update: XOR<MentoriaUpdateWithoutEmprendimientoInput, MentoriaUncheckedUpdateWithoutEmprendimientoInput>
    create: XOR<MentoriaCreateWithoutEmprendimientoInput, MentoriaUncheckedCreateWithoutEmprendimientoInput>
  }

  export type MentoriaUpdateWithWhereUniqueWithoutEmprendimientoInput = {
    where: MentoriaWhereUniqueInput
    data: XOR<MentoriaUpdateWithoutEmprendimientoInput, MentoriaUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type MentoriaUpdateManyWithWhereWithoutEmprendimientoInput = {
    where: MentoriaScalarWhereInput
    data: XOR<MentoriaUpdateManyMutationInput, MentoriaUncheckedUpdateManyWithoutEmprendimientoInput>
  }

  export type ResenaUpsertWithWhereUniqueWithoutEmprendimientoInput = {
    where: ResenaWhereUniqueInput
    update: XOR<ResenaUpdateWithoutEmprendimientoInput, ResenaUncheckedUpdateWithoutEmprendimientoInput>
    create: XOR<ResenaCreateWithoutEmprendimientoInput, ResenaUncheckedCreateWithoutEmprendimientoInput>
  }

  export type ResenaUpdateWithWhereUniqueWithoutEmprendimientoInput = {
    where: ResenaWhereUniqueInput
    data: XOR<ResenaUpdateWithoutEmprendimientoInput, ResenaUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type ResenaUpdateManyWithWhereWithoutEmprendimientoInput = {
    where: ResenaScalarWhereInput
    data: XOR<ResenaUpdateManyMutationInput, ResenaUncheckedUpdateManyWithoutEmprendimientoInput>
  }

  export type PromocionUpsertWithWhereUniqueWithoutEmprendimientoInput = {
    where: PromocionWhereUniqueInput
    update: XOR<PromocionUpdateWithoutEmprendimientoInput, PromocionUncheckedUpdateWithoutEmprendimientoInput>
    create: XOR<PromocionCreateWithoutEmprendimientoInput, PromocionUncheckedCreateWithoutEmprendimientoInput>
  }

  export type PromocionUpdateWithWhereUniqueWithoutEmprendimientoInput = {
    where: PromocionWhereUniqueInput
    data: XOR<PromocionUpdateWithoutEmprendimientoInput, PromocionUncheckedUpdateWithoutEmprendimientoInput>
  }

  export type PromocionUpdateManyWithWhereWithoutEmprendimientoInput = {
    where: PromocionScalarWhereInput
    data: XOR<PromocionUpdateManyMutationInput, PromocionUncheckedUpdateManyWithoutEmprendimientoInput>
  }

  export type PromocionScalarWhereInput = {
    AND?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
    OR?: PromocionScalarWhereInput[]
    NOT?: PromocionScalarWhereInput | PromocionScalarWhereInput[]
    id?: IntFilter<"Promocion"> | number
    titulo?: StringFilter<"Promocion"> | string
    descripcion?: StringNullableFilter<"Promocion"> | string | null
    fechaInicio?: DateTimeFilter<"Promocion"> | Date | string
    fechaFin?: DateTimeFilter<"Promocion"> | Date | string
    descuento?: StringNullableFilter<"Promocion"> | string | null
    activo?: BoolFilter<"Promocion"> | boolean
    emprendimientoId?: IntFilter<"Promocion"> | number
  }

  export type EmprendimientoCreateWithoutProductosInput = {
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    categoria: CategoriaCreateNestedOneWithoutEmprendimientosInput
    redesSociales?: RedesSocialesCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutProductosInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuarioId: number
    categoriaId: number
    redesSociales?: RedesSocialesUncheckedCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaUncheckedCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutProductosInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutProductosInput, EmprendimientoUncheckedCreateWithoutProductosInput>
  }

  export type EmprendimientoUpsertWithoutProductosInput = {
    update: XOR<EmprendimientoUpdateWithoutProductosInput, EmprendimientoUncheckedUpdateWithoutProductosInput>
    create: XOR<EmprendimientoCreateWithoutProductosInput, EmprendimientoUncheckedCreateWithoutProductosInput>
    where?: EmprendimientoWhereInput
  }

  export type EmprendimientoUpdateToOneWithWhereWithoutProductosInput = {
    where?: EmprendimientoWhereInput
    data: XOR<EmprendimientoUpdateWithoutProductosInput, EmprendimientoUncheckedUpdateWithoutProductosInput>
  }

  export type EmprendimientoUpdateWithoutProductosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutEmprendimientosNestedInput
    redesSociales?: RedesSocialesUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutProductosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuarioId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    redesSociales?: RedesSocialesUncheckedUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoCreateWithoutRedesSocialesInput = {
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    categoria: CategoriaCreateNestedOneWithoutEmprendimientosInput
    productos?: ProductoCreateNestedManyWithoutEmprendimientoInput
    mentorias?: MentoriaCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutRedesSocialesInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuarioId: number
    categoriaId: number
    productos?: ProductoUncheckedCreateNestedManyWithoutEmprendimientoInput
    mentorias?: MentoriaUncheckedCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutRedesSocialesInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutRedesSocialesInput, EmprendimientoUncheckedCreateWithoutRedesSocialesInput>
  }

  export type EmprendimientoUpsertWithoutRedesSocialesInput = {
    update: XOR<EmprendimientoUpdateWithoutRedesSocialesInput, EmprendimientoUncheckedUpdateWithoutRedesSocialesInput>
    create: XOR<EmprendimientoCreateWithoutRedesSocialesInput, EmprendimientoUncheckedCreateWithoutRedesSocialesInput>
    where?: EmprendimientoWhereInput
  }

  export type EmprendimientoUpdateToOneWithWhereWithoutRedesSocialesInput = {
    where?: EmprendimientoWhereInput
    data: XOR<EmprendimientoUpdateWithoutRedesSocialesInput, EmprendimientoUncheckedUpdateWithoutRedesSocialesInput>
  }

  export type EmprendimientoUpdateWithoutRedesSocialesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutEmprendimientosNestedInput
    productos?: ProductoUpdateManyWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutRedesSocialesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuarioId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type UsuarioCreateWithoutMentoriasComoTutorInput = {
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    roles?: RolCreateNestedManyWithoutUsuariosInput
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutMentoriasComoTutorInput = {
    id?: number
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    roles?: RolUncheckedCreateNestedManyWithoutUsuariosInput
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutMentoriasComoTutorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutMentoriasComoTutorInput, UsuarioUncheckedCreateWithoutMentoriasComoTutorInput>
  }

  export type EmprendimientoCreateWithoutMentoriasInput = {
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    categoria: CategoriaCreateNestedOneWithoutEmprendimientosInput
    productos?: ProductoCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesCreateNestedOneWithoutEmprendimientoInput
    resenas?: ResenaCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutMentoriasInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuarioId: number
    categoriaId: number
    productos?: ProductoUncheckedCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesUncheckedCreateNestedOneWithoutEmprendimientoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutMentoriasInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutMentoriasInput, EmprendimientoUncheckedCreateWithoutMentoriasInput>
  }

  export type UsuarioUpsertWithoutMentoriasComoTutorInput = {
    update: XOR<UsuarioUpdateWithoutMentoriasComoTutorInput, UsuarioUncheckedUpdateWithoutMentoriasComoTutorInput>
    create: XOR<UsuarioCreateWithoutMentoriasComoTutorInput, UsuarioUncheckedCreateWithoutMentoriasComoTutorInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutMentoriasComoTutorInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutMentoriasComoTutorInput, UsuarioUncheckedUpdateWithoutMentoriasComoTutorInput>
  }

  export type UsuarioUpdateWithoutMentoriasComoTutorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    roles?: RolUpdateManyWithoutUsuariosNestedInput
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutMentoriasComoTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    roles?: RolUncheckedUpdateManyWithoutUsuariosNestedInput
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type EmprendimientoUpsertWithoutMentoriasInput = {
    update: XOR<EmprendimientoUpdateWithoutMentoriasInput, EmprendimientoUncheckedUpdateWithoutMentoriasInput>
    create: XOR<EmprendimientoCreateWithoutMentoriasInput, EmprendimientoUncheckedCreateWithoutMentoriasInput>
    where?: EmprendimientoWhereInput
  }

  export type EmprendimientoUpdateToOneWithWhereWithoutMentoriasInput = {
    where?: EmprendimientoWhereInput
    data: XOR<EmprendimientoUpdateWithoutMentoriasInput, EmprendimientoUncheckedUpdateWithoutMentoriasInput>
  }

  export type EmprendimientoUpdateWithoutMentoriasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutEmprendimientosNestedInput
    productos?: ProductoUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUpdateOneWithoutEmprendimientoNestedInput
    resenas?: ResenaUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutMentoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuarioId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUncheckedUpdateOneWithoutEmprendimientoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type UsuarioCreateWithoutResenasInput = {
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthCreateNestedOneWithoutUsuarioInput
    roles?: RolCreateNestedManyWithoutUsuariosInput
    emprendimientos?: EmprendimientoCreateNestedManyWithoutUsuarioInput
    mentoriasComoTutor?: MentoriaCreateNestedManyWithoutTutorInput
  }

  export type UsuarioUncheckedCreateWithoutResenasInput = {
    id?: number
    nombre: string
    apellido: string
    email: string
    telefono?: string | null
    fechaRegistro?: Date | string
    auth?: AuthUncheckedCreateNestedOneWithoutUsuarioInput
    roles?: RolUncheckedCreateNestedManyWithoutUsuariosInput
    emprendimientos?: EmprendimientoUncheckedCreateNestedManyWithoutUsuarioInput
    mentoriasComoTutor?: MentoriaUncheckedCreateNestedManyWithoutTutorInput
  }

  export type UsuarioCreateOrConnectWithoutResenasInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
  }

  export type EmprendimientoCreateWithoutResenasInput = {
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    categoria: CategoriaCreateNestedOneWithoutEmprendimientosInput
    productos?: ProductoCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutResenasInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuarioId: number
    categoriaId: number
    productos?: ProductoUncheckedCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesUncheckedCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaUncheckedCreateNestedManyWithoutEmprendimientoInput
    promociones?: PromocionUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutResenasInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutResenasInput, EmprendimientoUncheckedCreateWithoutResenasInput>
  }

  export type UsuarioUpsertWithoutResenasInput = {
    update: XOR<UsuarioUpdateWithoutResenasInput, UsuarioUncheckedUpdateWithoutResenasInput>
    create: XOR<UsuarioCreateWithoutResenasInput, UsuarioUncheckedCreateWithoutResenasInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutResenasInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutResenasInput, UsuarioUncheckedUpdateWithoutResenasInput>
  }

  export type UsuarioUpdateWithoutResenasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    roles?: RolUpdateManyWithoutUsuariosNestedInput
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    mentoriasComoTutor?: MentoriaUpdateManyWithoutTutorNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutResenasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    roles?: RolUncheckedUpdateManyWithoutUsuariosNestedInput
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    mentoriasComoTutor?: MentoriaUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type EmprendimientoUpsertWithoutResenasInput = {
    update: XOR<EmprendimientoUpdateWithoutResenasInput, EmprendimientoUncheckedUpdateWithoutResenasInput>
    create: XOR<EmprendimientoCreateWithoutResenasInput, EmprendimientoUncheckedCreateWithoutResenasInput>
    where?: EmprendimientoWhereInput
  }

  export type EmprendimientoUpdateToOneWithWhereWithoutResenasInput = {
    where?: EmprendimientoWhereInput
    data: XOR<EmprendimientoUpdateWithoutResenasInput, EmprendimientoUncheckedUpdateWithoutResenasInput>
  }

  export type EmprendimientoUpdateWithoutResenasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutEmprendimientosNestedInput
    productos?: ProductoUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutResenasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuarioId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUncheckedUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoCreateWithoutPromocionesInput = {
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuario: UsuarioCreateNestedOneWithoutEmprendimientosInput
    categoria: CategoriaCreateNestedOneWithoutEmprendimientosInput
    productos?: ProductoCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoUncheckedCreateWithoutPromocionesInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuarioId: number
    categoriaId: number
    productos?: ProductoUncheckedCreateNestedManyWithoutEmprendimientoInput
    redesSociales?: RedesSocialesUncheckedCreateNestedOneWithoutEmprendimientoInput
    mentorias?: MentoriaUncheckedCreateNestedManyWithoutEmprendimientoInput
    resenas?: ResenaUncheckedCreateNestedManyWithoutEmprendimientoInput
  }

  export type EmprendimientoCreateOrConnectWithoutPromocionesInput = {
    where: EmprendimientoWhereUniqueInput
    create: XOR<EmprendimientoCreateWithoutPromocionesInput, EmprendimientoUncheckedCreateWithoutPromocionesInput>
  }

  export type EmprendimientoUpsertWithoutPromocionesInput = {
    update: XOR<EmprendimientoUpdateWithoutPromocionesInput, EmprendimientoUncheckedUpdateWithoutPromocionesInput>
    create: XOR<EmprendimientoCreateWithoutPromocionesInput, EmprendimientoUncheckedCreateWithoutPromocionesInput>
    where?: EmprendimientoWhereInput
  }

  export type EmprendimientoUpdateToOneWithWhereWithoutPromocionesInput = {
    where?: EmprendimientoWhereInput
    data: XOR<EmprendimientoUpdateWithoutPromocionesInput, EmprendimientoUncheckedUpdateWithoutPromocionesInput>
  }

  export type EmprendimientoUpdateWithoutPromocionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    categoria?: CategoriaUpdateOneRequiredWithoutEmprendimientosNestedInput
    productos?: ProductoUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutPromocionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuarioId?: IntFieldUpdateOperationsInput | number
    categoriaId?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUncheckedUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoCreateManyUsuarioInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    categoriaId: number
  }

  export type MentoriaCreateManyTutorInput = {
    id?: number
    tema: string
    fechaProgramada: Date | string
    estado?: $Enums.EstadoMentoria
    notas?: string | null
    emprendimientoId: number
  }

  export type ResenaCreateManyUsuarioInput = {
    id?: number
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    emprendimientoId: number
  }

  export type RolUpdateWithoutUsuariosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RolUncheckedUpdateWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type RolUncheckedUpdateManyWithoutUsuariosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
  }

  export type EmprendimientoUpdateWithoutUsuarioInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    categoria?: CategoriaUpdateOneRequiredWithoutEmprendimientosNestedInput
    productos?: ProductoUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    categoriaId?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUncheckedUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    categoriaId?: IntFieldUpdateOperationsInput | number
  }

  export type MentoriaUpdateWithoutTutorInput = {
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutMentoriasNestedInput
  }

  export type MentoriaUncheckedUpdateWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type MentoriaUncheckedUpdateManyWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type ResenaUpdateWithoutUsuarioInput = {
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimiento?: EmprendimientoUpdateOneRequiredWithoutResenasNestedInput
  }

  export type ResenaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type ResenaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    emprendimientoId?: IntFieldUpdateOperationsInput | number
  }

  export type UsuarioUpdateWithoutRolesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUpdateOneWithoutUsuarioNestedInput
    emprendimientos?: EmprendimientoUpdateManyWithoutUsuarioNestedInput
    mentoriasComoTutor?: MentoriaUpdateManyWithoutTutorNestedInput
    resenas?: ResenaUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    auth?: AuthUncheckedUpdateOneWithoutUsuarioNestedInput
    emprendimientos?: EmprendimientoUncheckedUpdateManyWithoutUsuarioNestedInput
    mentoriasComoTutor?: MentoriaUncheckedUpdateManyWithoutTutorNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmprendimientoCreateManyCategoriaInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    logoUrl?: string | null
    fechaCreacion?: Date | string
    estado?: $Enums.EstadoEmprendimiento
    usuarioId: number
  }

  export type EmprendimientoUpdateWithoutCategoriaInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuario?: UsuarioUpdateOneRequiredWithoutEmprendimientosNestedInput
    productos?: ProductoUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuarioId?: IntFieldUpdateOperationsInput | number
    productos?: ProductoUncheckedUpdateManyWithoutEmprendimientoNestedInput
    redesSociales?: RedesSocialesUncheckedUpdateOneWithoutEmprendimientoNestedInput
    mentorias?: MentoriaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    resenas?: ResenaUncheckedUpdateManyWithoutEmprendimientoNestedInput
    promociones?: PromocionUncheckedUpdateManyWithoutEmprendimientoNestedInput
  }

  export type EmprendimientoUncheckedUpdateManyWithoutCategoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoEmprendimientoFieldUpdateOperationsInput | $Enums.EstadoEmprendimiento
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductoCreateManyEmprendimientoInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    precio: Decimal | DecimalJsLike | number | string
    imagenUrl?: string | null
    activo?: boolean
  }

  export type MentoriaCreateManyEmprendimientoInput = {
    id?: number
    tema: string
    fechaProgramada: Date | string
    estado?: $Enums.EstadoMentoria
    notas?: string | null
    tutorId: number
  }

  export type ResenaCreateManyEmprendimientoInput = {
    id?: number
    calificacion: number
    comentario?: string | null
    fecha?: Date | string
    usuarioId: number
  }

  export type PromocionCreateManyEmprendimientoInput = {
    id?: number
    titulo: string
    descripcion?: string | null
    fechaInicio: Date | string
    fechaFin: Date | string
    descuento?: string | null
    activo?: boolean
  }

  export type ProductoUpdateWithoutEmprendimientoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoUncheckedUpdateWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductoUncheckedUpdateManyWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    imagenUrl?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MentoriaUpdateWithoutEmprendimientoInput = {
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    tutor?: UsuarioUpdateOneRequiredWithoutMentoriasComoTutorNestedInput
  }

  export type MentoriaUncheckedUpdateWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
  }

  export type MentoriaUncheckedUpdateManyWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tema?: StringFieldUpdateOperationsInput | string
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: EnumEstadoMentoriaFieldUpdateOperationsInput | $Enums.EstadoMentoria
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    tutorId?: IntFieldUpdateOperationsInput | number
  }

  export type ResenaUpdateWithoutEmprendimientoInput = {
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutResenasNestedInput
  }

  export type ResenaUncheckedUpdateWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type ResenaUncheckedUpdateManyWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    calificacion?: IntFieldUpdateOperationsInput | number
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuarioId?: IntFieldUpdateOperationsInput | number
  }

  export type PromocionUpdateWithoutEmprendimientoInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromocionUncheckedUpdateWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PromocionUncheckedUpdateManyWithoutEmprendimientoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    descuento?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolCountOutputTypeDefaultArgs instead
     */
    export type RolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaCountOutputTypeDefaultArgs instead
     */
    export type CategoriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmprendimientoCountOutputTypeDefaultArgs instead
     */
    export type EmprendimientoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmprendimientoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthDefaultArgs instead
     */
    export type AuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolDefaultArgs instead
     */
    export type RolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoriaDefaultArgs instead
     */
    export type CategoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmprendimientoDefaultArgs instead
     */
    export type EmprendimientoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmprendimientoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductoDefaultArgs instead
     */
    export type ProductoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RedesSocialesDefaultArgs instead
     */
    export type RedesSocialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RedesSocialesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentoriaDefaultArgs instead
     */
    export type MentoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResenaDefaultArgs instead
     */
    export type ResenaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResenaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromocionDefaultArgs instead
     */
    export type PromocionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromocionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}